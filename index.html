<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense (Upgrades)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Using Inter font, as it's a nice default included with Tailwind */
        body { font-family: 'Inter', sans-serif; }
        
        /* Add a visual cue for the selected tower */
        .tower-button.selected {
            border-color: #3b82f6 !important; /* blue-500 */
            box-shadow: 0 0 10px #3b82f6;
        }
        
        /* Base button style for consistent hover/active states */
        .game-button {
            transition: all 0.1s ease-in-out;
        }
        .game-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .game-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: none;
        }
        
        /* Hide scrollbars but keep functionality */
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        
        /* This container is crucial. It holds the canvas and gives it a 
          responsive 4:3 aspect ratio, which our resizeCanvas() function uses.
        */
        #game-canvas-container {
            width: 100%;
            max-width: 800px; /* Corresponds to canvas.width */
            aspect-ratio: 4 / 3;
            margin-left: auto;
            margin-right: auto;
            position: relative; /* For turret menu positioning */
        }
        canvas {
            display: block;
            background-color: #374151; /* gray-700, to see the game area */
        }
        
        /* Game container should fit viewport */
        #game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            max-width: 100vw;
        }
        
        /* Level select cards */
        .level-card {
            min-width: 300px;
            max-width: 400px;
            scroll-snap-align: center;
        }
    </style>
    
    <script type="module">
        // === GAME SETUP ===
        
        // Local game state
        let gameLoopId = null; // To stop the game loop
        
        // --- UI Elements ---
        // These will be assigned in init() after the page loads
        let loadingOverlay, startMenu, mainMenu, gameContainer, levelSelectContainer, armoryContainer, gemDisplay, gemDisplayStart;
        let navLevels, navArmory, levelSelectView, armoryView, levelNavLeft, levelNavRight, backToStartBtn, startPlayBtn;
        let canvas, ctx, moneyDisplay, livesDisplay, levelDisplay, waveDisplay, startWaveBtn, towerSelectionUI, backToMenuBtn;
        let messageBox, messageTitle, messageText, messageButton1, messageButton2;
        // --- NEW UPGRADE UI ELEMENTS ---
        let turretMenu, turretMenuTitle, turretMenuStats, turretMenuUpgrade, turretMenuSell, turretMenuClose, turretMenuUpgradePreview;
        
        // --- DEBUG MENU ELEMENTS ---
        let debugMenu, debugClose, debugAddGems, debugAddMoney, debugUnlockAll, debugMaxAll, debugAddLives;

        let canvasWidth, canvasHeight;

        // Game State (In-Level)
        let money = 0;
        let lives = 0; // This is 'Base HP'
        let currentLevel = 0;
        let currentWave = 0;
        let gameState = 'waiting'; // 'waiting', 'playing', 'gameover', 'win'
        let selectedTowerType = null; // e.g., 'basic' (for building)
        let selectedTurret = null; // The actual turret object on the map (for upgrading)
        let mouse = { x: 0, y: 0 };
        let lastTime = 0;

        // Game Objects (In-Level)
        let turrets = [];
        let enemies = [];
        let projectiles = [];
        let particles = []; // For visual effects
        let spawnQueue = [];
        let spawnCounter = 0;
        let currentPath = []; // Will be set when level loads
        const pathWidth = 30;
        
        // --- Player's Data (Resets on Refresh) ---
        // NEW DATA STRUCTURE:
        // 0 = Locked
        // 1 = Unlocked (Base Level 1)
        // 2 = Max Level 2
        // 3 = Max Level 3
        let playerData = {
            gems: 10,
            turretMaxLevels: {
                'basic': 1,
                'sniper': 0,
                'flamethrower': 0
            }
        };


        // === GAME DATA ===
        // These will be loaded from CSV files
        let turretTypes = {};
        let enemyTypes = {};
        let levels = [];

        // === CSV PARSING FUNCTIONS ===

        async function loadCSV(filename) {
            try {
                // Add cache-busting parameter to ensure fresh data
                const cacheBuster = `?v=${Date.now()}`;
                const response = await fetch(filename + cacheBuster);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}: ${response.status} ${response.statusText}`);
                }
                const text = await response.text();
                if (!text || text.trim().length === 0) {
                    throw new Error(`${filename} is empty or could not be read`);
                }
                return text;
            } catch (error) {
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    throw new Error(`Cannot load ${filename}. This usually means you're opening the file directly. Please use a local web server.`);
                }
                throw error;
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                const row = {};
                headers.forEach((header, index) => {
                    row[header.trim()] = values[index] !== undefined ? values[index].trim() : '';
                });
                data.push(row);
            }
            
            return data;
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current);
            
            return values;
        }

        function parsePath(pathString) {
            // Path format: "x1,y1|x2,y2|x3,y3"
            const points = pathString.split('|');
            return points.map(point => {
                const [x, y] = point.split(',');
                return { x: parseFloat(x), y: parseFloat(y) };
            });
        }

        function parseArray(arrayString) {
            // Array format: "val1|val2|val3"
            if (!arrayString) return [];
            return arrayString.split('|').map(val => parseFloat(val.trim())).filter(val => !isNaN(val));
        }

        function parseEnemies(enemiesString) {
            // Format: "type1:count1:spawnRate1:delay1+type2:count2:spawnRate2:delay2"
            const groups = enemiesString.split('+');
            return groups.map(group => {
                const parts = group.split(':');
                const enemy = {
                    type: parts[0].trim(),
                    count: parseInt(parts[1]) || 0,
                    spawnRate: parseInt(parts[2]) || 60
                };
                if (parts[3]) {
                    enemy.delay = parseInt(parts[3]);
                }
                return enemy;
            });
        }

        async function loadGameData() {
            try {
                // Check if we're running from file:// protocol (which doesn't support fetch)
                if (window.location.protocol === 'file:') {
                    throw new Error('Cannot load CSV files from file:// protocol. Please use a local web server (e.g., python -m http.server or live-server).');
                }
                
                // Load enemies
                const enemiesCSV = await loadCSV('enemies.csv');
                const enemiesData = parseCSV(enemiesCSV);
                enemyTypes = {};
                enemiesData.forEach(row => {
                    enemyTypes[row.id] = {
                        hp: parseFloat(row.hp),
                        speed: parseFloat(row.speed),
                        reward: parseFloat(row.reward),
                        damage: parseFloat(row.damage),
                        color: row.color,
                        radius: parseFloat(row.radius)
                    };
                });

                // Load turrets
                const turretsCSV = await loadCSV('turrets.csv');
                const turretsLines = turretsCSV.trim().split('\n');
                const headers = turretsLines[0].split(',').map(h => h.trim());
                turretTypes = {};
                
                // Parse turrets manually to handle empty column
                // Column structure: id, name, cost, damage, range, fireRate, projectileColor, projectileSpeed, 
                // color, description, gemUnlockCost, inGameUpgradeCost (actually gemUpgradeCost), 
                // empty, inGameUpgradeCost (no header), damageUpgrade, rangeUpgrade, fireRateUpgrade
                for (let i = 1; i < turretsLines.length; i++) {
                    const rowValues = parseCSVLine(turretsLines[i]);
                    const row = {};
                    headers.forEach((header, index) => {
                        if (header) { // Skip empty header columns
                            row[header] = rowValues[index] !== undefined ? rowValues[index].trim() : '';
                        }
                    });
                    
                    const id = row.id.toLowerCase();
                    // Find indices: gemUpgradeCost is at index of 'inGameUpgradeCost' header (11)
                    // inGameUpgradeCost is at index 12 (right after the 'inGameUpgradeCost' header column)
                    const gemUpgradeCostIndex = headers.indexOf('inGameUpgradeCost'); // Should be 11
                    const inGameUpgradeCostIndex = gemUpgradeCostIndex + 1; // Next column after gemUpgradeCost
                    
                    const gemUpgradeCostArray = parseArray(rowValues[gemUpgradeCostIndex] || '');
                    const inGameUpgradeCostArray = parseArray(rowValues[inGameUpgradeCostIndex] || '');
                    
                    console.log(`Turret ${id}: gemUpgradeCost=${rowValues[gemUpgradeCostIndex]}, inGameUpgradeCost=${rowValues[inGameUpgradeCostIndex]}`);
                    console.log(`Turret ${id}: parsed gemUpgradeCost=`, gemUpgradeCostArray, `inGameUpgradeCost=`, inGameUpgradeCostArray);
                    
                    turretTypes[id] = {
                        name: row.name,
                        cost: parseFloat(row.cost),
                        damage: parseFloat(row.damage),
                        range: parseFloat(row.range),
                        fireRate: parseFloat(row.fireRate),
                        projectileColor: row.projectileColor,
                        projectileSpeed: parseFloat(row.projectileSpeed),
                        color: row.color,
                        description: row.description,
                        gemUnlockCost: parseFloat(row.gemUnlockCost) || 0,
                        gemUpgradeCost: gemUpgradeCostArray,
                        inGameUpgradeCost: inGameUpgradeCostArray,
                        statUpgrades: {
                            damage: parseFloat(row.damageUpgrade) || 0,
                            range: parseFloat(row.rangeUpgrade) || 0,
                            fireRate: parseFloat(row.fireRateUpgrade) || 0
                        }
                    };
                }

                // Load levels
                const levelsCSV = await loadCSV('levels.csv');
                const levelsLines = levelsCSV.trim().split('\n');
                levels = [];
                
                // Parse levels manually because path contains unquoted commas
                for (let i = 1; i < levelsLines.length; i++) {
                    const line = levelsLines[i];
                    
                    // Find the 5th comma (after gemReward)
                    let commaCount = 0;
                    let pathStartIndex = 0;
                    for (let j = 0; j < line.length; j++) {
                        if (line[j] === ',') {
                            commaCount++;
                            if (commaCount === 5) {
                                pathStartIndex = j + 1;
                                break;
                            }
                        }
                    }
                    
                    // Extract first 5 fields
                    const firstPart = line.substring(0, pathStartIndex - 1);
                    const firstValues = firstPart.split(',');
                    const level = parseInt(firstValues[0]);
                    const startingMoney = parseFloat(firstValues[1]);
                    const startingLives = parseFloat(firstValues[2]);
                    const difficulty = firstValues[3];
                    const gemReward = parseFloat(firstValues[4]);
                    
                    // Extract path (everything after the 5th comma)
                    const pathString = line.substring(pathStartIndex);
                    const parsedPath = parsePath(pathString);
                    
                    console.log(`Level ${level} path string:`, pathString);
                    console.log(`Level ${level} parsed path:`, parsedPath);
                    
                    levels.push({
                        path: parsedPath,
                        startingMoney: startingMoney,
                        startingLives: startingLives,
                        difficulty: difficulty,
                        gemReward: gemReward,
                        waves: [] // Will be populated from waves.csv
                    });
                }

                // Load waves
                const wavesCSV = await loadCSV('waves.csv');
                const wavesData = parseCSV(wavesCSV);
                wavesData.forEach(row => {
                    const levelIndex = parseInt(row.level) - 1;
                    const waveIndex = parseInt(row.wave) - 1;
                    
                    if (!levels[levelIndex]) return;
                    if (!levels[levelIndex].waves[waveIndex]) {
                        levels[levelIndex].waves[waveIndex] = { enemies: [] };
                    }
                    
                    const enemyGroups = parseEnemies(row.enemies);
                    levels[levelIndex].waves[waveIndex].enemies = enemyGroups;
                });

                console.log('Game data loaded successfully');
                return true;
            } catch (error) {
                console.error('Error loading game data:', error);
                console.error('Error details:', error.message, error.stack);
                throw error; // Re-throw to show in UI
            }
        }
        
        // === NEW HELPER FUNCTIONS ===

        /**
         * Calculates the stats of a turret at a specific level.
         * This is the single source of truth for all turret stats.
         */
        function getTurretStats(type, level) {
            const baseStats = turretTypes[type];
            if (!baseStats) return null;

            const calculatedStats = {
                name: baseStats.name,
                color: baseStats.color,
                projectileColor: baseStats.projectileColor,
                projectileSpeed: baseStats.projectileSpeed,
                cost: baseStats.cost, // Base cost is always for Lvl 1
                
                // Calculate stats based on level
                damage: baseStats.damage + (baseStats.statUpgrades.damage * (level - 1)),
                range: baseStats.range + (baseStats.statUpgrades.range * (level - 1)),
                fireRate: Math.max(1, baseStats.fireRate + (baseStats.statUpgrades.fireRate * (level - 1))), // Don't let fireRate be 0 or less
                
                // Calculate total cost (for sell value)
                totalCost: baseStats.cost,
                nextUpgradeCost: null
            };

            // Calculate total spent and cost for next upgrade
            for (let i = 0; i < level - 1; i++) {
                calculatedStats.totalCost += baseStats.inGameUpgradeCost[i] || 0;
            }
            
            // Get cost for the *next* level
            if (level < 10) { // Assume a max level cap for safety
                 calculatedStats.nextUpgradeCost = baseStats.inGameUpgradeCost[level - 1]; // e.g., for Lvl 1, this gets cost to Lvl 2 (index 0)
            }
           
            calculatedStats.sellValue = Math.floor(calculatedStats.totalCost * 0.7);

            return calculatedStats;
        }

        /** Gets a list of turret IDs that are unlocked (max level > 0) */
        function getUnlockedTurrets() {
            return Object.keys(playerData.turretMaxLevels).filter(id => playerData.turretMaxLevels[id] > 0);
        }

        
        // === MAIN MENU & UI LOGIC ===
        
        function showMainMenu() {
            // Hide game, show menu
            gameContainer.style.display = 'none';
            startMenu.style.display = 'none';
            mainMenu.style.display = 'flex';
            messageBox.style.display = 'none';
            closeTurretMenu();
            
            // Stop game loop if it's running
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            // Refresh menu data
            updateMenuUI();
            switchMenuTab('levels'); // Default to levels tab
        }
        
        function updateMenuUI() {
            if (!playerData) return;
            
            gemDisplay.textContent = playerData.gems || 0;
            if (gemDisplayStart) gemDisplayStart.textContent = playerData.gems || 0;
            
            // --- Populate Level Select with horizontal cards ---
            levelSelectContainer.innerHTML = ''; // Clear old list
            levels.forEach((level, index) => {
                const levelCard = document.createElement('div');
                levelCard.className = 'level-card bg-gray-800 p-6 rounded-xl shadow-2xl mx-4 flex flex-col justify-between';
                
                const difficultyColor = level.difficulty === 'Easy' ? 'text-green-400' : 
                                       level.difficulty === 'Medium' ? 'text-yellow-400' : 
                                       level.difficulty === 'Hard' ? 'text-orange-400' :
                                       level.difficulty === 'Very Hard' ? 'text-red-400' : 'text-purple-400';
                
                levelCard.innerHTML = `
                    <div>
                        <h3 class="text-2xl font-bold text-white mb-2">Level ${index + 1}</h3>
                        <p class="text-lg mb-3">
                            <span class="font-semibold ${difficultyColor}">${level.difficulty}</span>
                        </p>
                        <div class="space-y-2 text-sm text-gray-300">
                            <p>Waves: <span class="font-semibold text-blue-300">${level.waves.length}</span></p>
                            <p>Starting Money: <span class="font-semibold text-green-300">$${level.startingMoney}</span></p>
                            <p>Starting Lives: <span class="font-semibold text-red-300">${level.startingLives}</span></p>
                            <p>Reward: <span class="font-semibold text-purple-300">${level.gemReward} Gems</span></p>
                        </div>
                    </div>
                    <button class="mt-4 game-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg w-full">
                        Play Level
                    </button>
                `;
                
                levelCard.querySelector('button').onclick = () => startGame(index);
                levelSelectContainer.appendChild(levelCard);
            });
            
            // --- Populate Armory with upgrade comparisons ---
            armoryContainer.innerHTML = ''; // Clear old list
            Object.entries(turretTypes).forEach(([id, stats]) => {
                const currentMaxLevel = playerData.turretMaxLevels[id] || 0;
                const baseStats = getTurretStats(id, 1);
                const maxStats = getTurretStats(id, currentMaxLevel || 1);
                const nextLevelStats = currentMaxLevel > 0 && currentMaxLevel < 4 ? getTurretStats(id, currentMaxLevel + 1) : null;
                
                const turretCard = document.createElement('div');
                turretCard.className = 'bg-gray-800 p-6 rounded-xl shadow-2xl';
                
                let upgradePreview = '';
                if (nextLevelStats && currentMaxLevel > 0) {
                    const dmgDiff = nextLevelStats.damage - maxStats.damage;
                    const rangeDiff = nextLevelStats.range - maxStats.range;
                    const rateDiff = nextLevelStats.fireRate - maxStats.fireRate;
                    upgradePreview = `
                        <div class="mt-4 p-3 bg-gray-700 rounded-lg border border-purple-500">
                            <p class="text-xs text-purple-300 font-semibold mb-2">Next Level Preview:</p>
                            <div class="text-xs space-y-1">
                                ${dmgDiff > 0 ? `<p>Damage: <span class="text-green-400">+${dmgDiff}</span></p>` : ''}
                                ${rangeDiff > 0 ? `<p>Range: <span class="text-blue-400">+${rangeDiff}</span></p>` : ''}
                                ${rateDiff < 0 ? `<p>Fire Rate: <span class="text-yellow-400">${rateDiff} (faster)</span></p>` : rateDiff > 0 ? `<p>Fire Rate: <span class="text-red-400">+${rateDiff} (slower)</span></p>` : ''}
                            </div>
                        </div>
                    `;
                }
                
                turretCard.innerHTML = `
                    <div>
                        <h3 class="text-2xl font-bold mb-2" style="color:${stats.color}">${stats.name}</h3>
                        <p class="text-sm text-gray-400 mb-4">${stats.description}</p>
                        
                        <div class="grid grid-cols-2 gap-4 mb-4">
                            <div class="bg-gray-700 p-3 rounded-lg">
                                <p class="text-xs text-gray-400 mb-1">Level 1 Stats</p>
                                <p class="text-sm">Cost: <span class="font-bold text-green-300">$${baseStats.cost}</span></p>
                                <p class="text-sm">DMG: <span class="font-bold text-red-300">${baseStats.damage}</span></p>
                                <p class="text-sm">Range: <span class="font-bold text-blue-300">${baseStats.range}</span></p>
                                <p class="text-sm">Rate: <span class="font-bold text-yellow-300">${baseStats.fireRate}</span></p>
                            </div>
                            <div class="bg-gray-700 p-3 rounded-lg">
                                <p class="text-xs text-gray-400 mb-1">Max Level ${currentMaxLevel || 'Locked'} Stats</p>
                                ${currentMaxLevel > 0 ? `
                                    <p class="text-sm">DMG: <span class="font-bold text-red-300">${maxStats.damage}</span></p>
                                    <p class="text-sm">Range: <span class="font-bold text-blue-300">${maxStats.range}</span></p>
                                    <p class="text-sm">Rate: <span class="font-bold text-yellow-300">${maxStats.fireRate}</span></p>
                                ` : '<p class="text-sm text-gray-500">Locked</p>'}
                            </div>
                        </div>
                        
                        ${upgradePreview}
                        
                        <p class="text-sm text-gray-400 mt-3">
                            Current Max Level: <span class="font-bold text-yellow-400">${currentMaxLevel}</span>
                        </p>
                    </div>
                `;
                
                const unlockButton = document.createElement('button');
                unlockButton.className = 'game-button text-white font-bold py-3 px-6 rounded-lg w-full mt-4 text-center';
                
                if (currentMaxLevel === 0) {
                    unlockButton.textContent = `Unlock (${stats.gemUnlockCost} Gems)`;
                    if (playerData.gems >= stats.gemUnlockCost) {
                        unlockButton.className += ' bg-purple-600 hover:bg-purple-700';
                        unlockButton.onclick = () => unlockTurret(id, stats.gemUnlockCost);
                    } else {
                        unlockButton.className += ' bg-red-700 cursor-not-allowed';
                        unlockButton.disabled = true;
                    }
                } else {
                    const nextUpgradeCost = stats.gemUpgradeCost[currentMaxLevel - 1];
                    if (nextUpgradeCost !== undefined) {
                        unlockButton.textContent = `Upgrade Max to Lvl ${currentMaxLevel + 1} (${nextUpgradeCost} Gems)`;
                        if (playerData.gems >= nextUpgradeCost) {
                            unlockButton.className += ' bg-purple-600 hover:bg-purple-700';
                            unlockButton.onclick = () => upgradeMaxTurretLevel(id, nextUpgradeCost);
                        } else {
                            unlockButton.className += ' bg-red-700 cursor-not-allowed';
                            unlockButton.disabled = true;
                        }
                    } else {
                        unlockButton.textContent = 'Maxed Out';
                        unlockButton.className += ' bg-gray-600 cursor-not-allowed';
                        unlockButton.disabled = true;
                    }
                }
                
                turretCard.appendChild(unlockButton);
                armoryContainer.appendChild(turretCard);
            });
        }
        
        function unlockTurret(turretId, cost) {
            if (playerData.gems >= cost && (playerData.turretMaxLevels[turretId] || 0) === 0) {
                playerData.gems -= cost;
                playerData.turretMaxLevels[turretId] = 1; // Set max level to 1
                updateMenuUI();
            }
        }
        
        function upgradeMaxTurretLevel(turretId, cost) {
            if (playerData.gems >= cost && (playerData.turretMaxLevels[turretId] || 0) > 0) {
                playerData.gems -= cost;
                playerData.turretMaxLevels[turretId]++;
                updateMenuUI();
            }
        }
        
        // === DEBUG MENU FUNCTIONS ===
        
        function toggleDebugMenu() {
            if (debugMenu) {
                debugMenu.classList.toggle('hidden');
            }
        }
        
        function unlockAllTurrets() {
            Object.keys(turretTypes).forEach(id => {
                if ((playerData.turretMaxLevels[id] || 0) === 0) {
                    playerData.turretMaxLevels[id] = 1; // Unlock at level 1
                }
            });
            updateMenuUI();
            if (gameContainer.style.display !== 'none') {
                setupTurretButtons(); // Update turret buttons in-game
            }
        }
        
        function maxAllTurretLevels() {
            Object.keys(turretTypes).forEach(id => {
                // Set to max level (4, since gemUpgradeCost has 3 values for levels 2, 3, 4)
                playerData.turretMaxLevels[id] = 4;
            });
            updateMenuUI();
        }
        
        // === CORE GAME LOGIC ===

        function startGame(levelIndex) {
            // Hide menu, show game
            mainMenu.style.display = 'none';
            gameContainer.style.display = 'block';
            
            // Resize canvas *after* it's visible
            resizeCanvas();
            
            loadLevel(levelIndex);
            
            // Start game loop
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // Function to resize canvas to fit its container
        function resizeCanvas() {
            const container = canvas.parentElement; 
            const rect = container.getBoundingClientRect();

            canvas.width = 800;
            canvas.height = 600;

            canvas.style.width = `${rect.width}px`;
            canvas.style.height = `${rect.height}px`;
            
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
        }

        // Initialize the game
        async function init() {
            // --- Assign all UI elements ---
            loadingOverlay = document.getElementById('loading-overlay');
            startMenu = document.getElementById('start-menu');
            mainMenu = document.getElementById('main-menu');
            gameContainer = document.getElementById('game-container');
            levelSelectContainer = document.getElementById('level-select-container');
            armoryContainer = document.getElementById('armory-container');
            gemDisplay = document.getElementById('gem-display');
            gemDisplayStart = document.getElementById('gem-display-start');
            
            // New menu elements
            navLevels = document.getElementById('nav-levels');
            navArmory = document.getElementById('nav-armory');
            levelSelectView = document.getElementById('level-select-view');
            armoryView = document.getElementById('armory-view');
            levelNavLeft = document.getElementById('level-nav-left');
            levelNavRight = document.getElementById('level-nav-right');
            backToStartBtn = document.getElementById('back-to-start-btn');
            startPlayBtn = document.getElementById('start-play-btn');

            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            moneyDisplay = document.getElementById('money-display');
            livesDisplay = document.getElementById('lives-display');
            levelDisplay = document.getElementById('level-display');
            waveDisplay = document.getElementById('wave-display');
            startWaveBtn = document.getElementById('start-wave-btn');
            towerSelectionUI = document.getElementById('tower-selection-ui');
            backToMenuBtn = document.getElementById('back-to-menu-btn');

            messageBox = document.getElementById('message-box');
            messageTitle = document.getElementById('message-title');
            messageText = document.getElementById('message-text');
            messageButton1 = document.getElementById('message-button-1');
            messageButton2 = document.getElementById('message-button-2');
            
            // --- Assign new turret menu elements ---
            turretMenu = document.getElementById('turret-menu');
            turretMenuTitle = document.getElementById('turret-menu-title');
            turretMenuStats = document.getElementById('turret-menu-stats');
            turretMenuUpgrade = document.getElementById('turret-menu-upgrade');
            turretMenuSell = document.getElementById('turret-menu-sell');
            turretMenuClose = document.getElementById('turret-menu-close');
            turretMenuUpgradePreview = document.getElementById('turret-menu-upgrade-preview');
            // --- End of element assignment ---

            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('click', onMouseClick);
            startWaveBtn.addEventListener('click', startWave);
            backToMenuBtn.addEventListener('click', showStartMenu);
            
            // Menu navigation
            startPlayBtn.addEventListener('click', showMainMenu);
            backToStartBtn.addEventListener('click', showStartMenu);
            navLevels.addEventListener('click', () => switchMenuTab('levels'));
            navArmory.addEventListener('click', () => switchMenuTab('armory'));
            levelNavLeft.addEventListener('click', () => scrollLevels(-1));
            levelNavRight.addEventListener('click', () => scrollLevels(1));

            // --- Turret Menu Listeners ---
            turretMenuClose.addEventListener('click', closeTurretMenu);
            turretMenuUpgrade.addEventListener('click', upgradeSelectedTurret);
            turretMenuSell.addEventListener('click', sellSelectedTurret);
            
            // --- Debug Menu Elements ---
            debugMenu = document.getElementById('debug-menu');
            debugClose = document.getElementById('debug-close');
            debugAddGems = document.getElementById('debug-add-gems');
            debugAddMoney = document.getElementById('debug-add-money');
            debugUnlockAll = document.getElementById('debug-unlock-all');
            debugMaxAll = document.getElementById('debug-max-all');
            debugAddLives = document.getElementById('debug-add-lives');
            
            // --- Debug Menu Listeners ---
            debugClose.addEventListener('click', toggleDebugMenu);
            debugAddGems.addEventListener('click', () => { playerData.gems += 100; updateMenuUI(); });
            debugAddMoney.addEventListener('click', () => { money += 1000; updateInGameUI(); });
            debugUnlockAll.addEventListener('click', unlockAllTurrets);
            debugMaxAll.addEventListener('click', maxAllTurretLevels);
            debugAddLives.addEventListener('click', () => { lives += 10; updateInGameUI(); });
            
            // --- Keyboard shortcut for debug menu (Press 'D') ---
            document.addEventListener('keydown', (e) => {
                if (e.key === 'd' || e.key === 'D') {
                    // Don't trigger if typing in an input field
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                        toggleDebugMenu();
                    }
                }
            });
            
            // Load game data from CSV files
            loadingOverlay.style.display = 'flex';
            try {
                await loadGameData();
            } catch (error) {
                loadingOverlay.innerHTML = `
                    <div class="text-center p-8">
                        <div class="text-2xl font-bold text-red-400 mb-4">Error loading game data</div>
                        <div class="text-lg text-gray-300 mb-4">${error.message}</div>
                        <div class="text-sm text-gray-400">
                            <p class="mb-2">If you're opening the HTML file directly, you need to use a local web server:</p>
                            <p class="mb-1"><strong>Python:</strong> python -m http.server 8000</p>
                            <p class="mb-1"><strong>Node.js:</strong> npx http-server</p>
                            <p class="mb-1"><strong>VS Code:</strong> Use the "Live Server" extension</p>
                            <p class="mt-4">Then open: http://localhost:8000/towerdefence.html</p>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Set default data and start
            const turretMaxLevels = {};
            Object.keys(turretTypes).forEach(id => {
                turretMaxLevels[id] = id === 'basic' ? 1 : 0;
            });
            
            playerData = {
                gems: 10,
                turretMaxLevels: turretMaxLevels
            };
            
            updateMenuUI();
            loadingOverlay.style.display = 'none';
            showStartMenu();
        }
        
        function showStartMenu() {
            startMenu.style.display = 'flex';
            mainMenu.style.display = 'none';
            gameContainer.style.display = 'none';
            messageBox.style.display = 'none';
            closeTurretMenu();
            
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            if (playerData) {
                gemDisplayStart.textContent = playerData.gems || 0;
            }
        }
        
        function switchMenuTab(tab) {
            if (tab === 'levels') {
                levelSelectView.classList.remove('hidden');
                armoryView.classList.add('hidden');
                navLevels.classList.remove('bg-gray-700');
                navLevels.classList.add('bg-blue-600', 'text-white');
                navArmory.classList.remove('bg-blue-600', 'text-white');
                navArmory.classList.add('bg-gray-700', 'text-gray-300');
            } else {
                levelSelectView.classList.add('hidden');
                armoryView.classList.remove('hidden');
                navArmory.classList.remove('bg-gray-700');
                navArmory.classList.add('bg-blue-600', 'text-white');
                navLevels.classList.remove('bg-blue-600', 'text-white');
                navLevels.classList.add('bg-gray-700', 'text-gray-300');
            }
        }
        
        function scrollLevels(direction) {
            const container = levelSelectContainer;
            const scrollAmount = 400;
            container.scrollBy({ left: scrollAmount * direction, behavior: 'smooth' });
        }

        // Load a level's data
        function loadLevel(levelIndex) {
            currentLevel = levelIndex;
            currentWave = 0;
            const levelData = levels[currentLevel];
            
            money = levelData.startingMoney;
            lives = levelData.startingLives;
            currentPath = levelData.path;
            
            turrets = [];
            enemies = [];
            projectiles = [];
            particles = [];
            spawnQueue = [];
            selectedTurret = null;
            selectedTowerType = null;
            
            gameState = 'waiting';
            updateInGameUI();
            setupTurretButtons(); // Populate turret bar
            closeTurretMenu();
            
            startWaveBtn.disabled = false;
            startWaveBtn.textContent = 'Start Wave';
        }
        
        // Dynamically create tower buttons based on unlocks
        function setupTurretButtons() {
            towerSelectionUI.innerHTML = ''; // Clear old buttons
            
            getUnlockedTurrets().forEach(turretId => {
                const stats = getTurretStats(turretId, 1); // Get Lvl 1 stats
                if (!stats) return;
                
                const button = document.createElement('button');
                button.id = `buy-${turretId}`;
                button.className = 'tower-button game-button bg-gray-800 p-3 rounded-lg border-2 border-gray-600 hover:border-blue-500';
                button.innerHTML = `
                    <div class="font-bold text-lg">${stats.name}</div>
                    <div class="text-sm text-gray-400">Cost: <span class="text-green-400">$${stats.cost}</span></div>
                    <div class="text-sm text-gray-400">${turretTypes[turretId].description}</div>
                `;
                button.onclick = () => selectTower(turretId);
                
                towerSelectionUI.appendChild(button);
            });
        }
        
        // Start the next wave
        function startWave() {
            if (gameState !== 'waiting' || !levels[currentLevel] || !levels[currentLevel].waves[currentWave]) return;
            
            closeTurretMenu(); // Close menu when wave starts
            
            gameState = 'playing';
            spawnQueue = [];
            spawnCounter = 0;
            
            const waveData = levels[currentLevel].waves[currentWave].enemies;
            
            waveData.forEach(group => {
                let spawnTime = group.delay || 0;
                for (let i = 0; i < group.count; i++) {
                    spawnQueue.push({ type: group.type, time: spawnTime });
                    spawnTime += group.spawnRate;
                }
            });
            
            spawnQueue.sort((a, b) => a.time - b.time);
            
            startWaveBtn.disabled = true;
            startWaveBtn.textContent = 'Wave in Progress...';
            updateInGameUI();
        }

        // Main Game Loop
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 16.67; // Normalize to ~60 FPS
            lastTime = timestamp;

            if (isNaN(deltaTime) || deltaTime <= 0) { // Skip first frame or bad timestamp
                gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            drawPath();
            
            if (gameState === 'playing') {
                handleSpawning(deltaTime);
                updateEnemies(deltaTime);
            }
            
            updateTurrets(deltaTime);
            updateProjectiles(deltaTime);
            updateParticles(deltaTime);

            drawTurrets();
            drawEnemies();
            drawProjectiles();
            drawParticles();
            drawGhostTower();
            
            if (gameState !== 'gameover' && gameState !== 'win') {
                gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                gameLoopId = null; // Stop loop
            }
        }

        // === UPDATE FUNCTIONS ===

        function handleSpawning(deltaTime) {
            if (spawnQueue.length > 0) {
                spawnCounter++; // This is a frame-based counter
                while(spawnQueue.length > 0 && spawnCounter >= spawnQueue[0].time) {
                    const enemyData = spawnQueue.shift();
                    spawnEnemy(enemyData.type);
                }
            } else if (enemies.length === 0) {
                // Check if spawnQueue is also empty, meaning all enemies are spawned and defeated
                endWave();
            }
        }
        
        function spawnEnemy(type) {
            const enemyData = enemyTypes[type];
            enemies.push({
                ...enemyData,
                x: currentPath[0].x,
                y: currentPath[0].y,
                currentHp: enemyData.hp,
                waypointIndex: 1
            });
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                if (enemy.currentHp <= 0) {
                    // Create death particles
                    createDeathParticles(enemy.x, enemy.y, enemy.color, enemy.radius);
                    money += enemy.reward;
                    updateInGameUI();
                    enemies.splice(i, 1);
                    continue;
                }

                const targetWaypoint = currentPath[enemy.waypointIndex];
                if (!targetWaypoint) continue; 

                const dx = targetWaypoint.x - enemy.x;
                const dy = targetWaypoint.y - enemy.y;
                const dist = Math.hypot(dx, dy);
                const moveDist = enemy.speed * deltaTime;

                if (dist < moveDist) {
                    enemy.x = targetWaypoint.x;
                    enemy.y = targetWaypoint.y;
                    enemy.waypointIndex++;
                    
                    if (enemy.waypointIndex >= currentPath.length) {
                        lives -= enemy.damage;
                        enemies.splice(i, 1);
                        updateInGameUI();
                        checkGameOver();
                    }
                } else {
                    enemy.x += (dx / dist) * moveDist;
                    enemy.y += (dy / dist) * moveDist;
                }
            }
        }
        
        function updateTurrets(deltaTime) {
            turrets.forEach(turret => {
                // Get the turret's stats for its CURRENT level
                const stats = getTurretStats(turret.type, turret.level);
                if (!stats) return; 
                
                const target = findTarget(turret, stats.range);
                
                if (target) {
                    turret.angle = Math.atan2(target.y - turret.y, target.x - turret.x);
                    
                    if (turret.cooldown <= 0) {
                        fireProjectile(turret, target, stats); // Pass stats in
                        turret.cooldown = stats.fireRate;
                    }
                }
                
                turret.cooldown -= 1 * deltaTime;
            });
        }
        
        function findTarget(turret, range) {
            let bestTarget = null;
            let maxDist = 0;

            for (const enemy of enemies) {
                const dist = Math.hypot(enemy.x - turret.x, enemy.y - turret.y);
                
                if (dist <= range) {
                    const enemyPathDist = getEnemyPathDistance(enemy);
                    if (enemyPathDist > maxDist) {
                        maxDist = enemyPathDist;
                        bestTarget = enemy;
                    }
                }
            }
            return bestTarget;
        }

        function getEnemyPathDistance(enemy) {
            let dist = 0;
            for (let i = 1; i < enemy.waypointIndex; i++) {
                dist += Math.hypot(currentPath[i].x - currentPath[i-1].x, currentPath[i].y - currentPath[i-1].y);
            }
            dist += Math.hypot(enemy.x - currentPath[enemy.waypointIndex-1].x, enemy.y - currentPath[enemy.waypointIndex-1].y);
            return dist;
        }
        
        function fireProjectile(turret, target, stats) {
            const gunTipX = turret.x + 18 * Math.cos(turret.angle);
            const gunTipY = turret.y + 18 * Math.sin(turret.angle);

            projectiles.push({
                x: gunTipX, y: gunTipY,
                damage: stats.damage, // Use calculated damage
                speed: stats.projectileSpeed, 
                color: stats.projectileColor,
                target: target, targetLost: false,
                lastTargetX: target.x, lastTargetY: target.y
            });
        }

        function updateProjectiles(deltaTime) {
             for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                
                if (!p.target || p.target.currentHp <= 0 || !enemies.includes(p.target)) {
                    p.targetLost = true;
                }
                
                let targetX = p.targetLost ? p.lastTargetX : p.target.x; 
                let targetY = p.targetLost ? p.lastTargetY : p.target.y;
                
                if (!p.targetLost) {
                    p.lastTargetX = targetX;
                    p.lastTargetY = targetY;
                }

                const dx = targetX - p.x;
                const dy = targetY - p.y;
                const dist = Math.hypot(dx, dy);
                const moveDist = p.speed * deltaTime;

                if (dist < moveDist) {
                    if (!p.targetLost && p.target) {
                         p.target.currentHp -= p.damage;
                    }
                    projectiles.splice(i, 1);
                } else {
                    p.x += (dx / dist) * moveDist;
                    p.y += (dy / dist) * moveDist;
                }
            }
        }
        
        // === DRAW FUNCTIONS ===
        
        function drawPath() {
            if (!currentPath || currentPath.length === 0) return;
            ctx.strokeStyle = '#1f2937'; // gray-900
            ctx.lineWidth = pathWidth + 4; 
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) ctx.lineTo(currentPath[i].x, currentPath[i].y);
            ctx.stroke();
            
            ctx.strokeStyle = '#9ca3af'; // gray-400
            ctx.lineWidth = pathWidth;
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) ctx.lineTo(currentPath[i].x, currentPath[i].y);
            ctx.stroke();
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                // Draw enemy with gradient and shadow for depth
                const gradient = ctx.createRadialGradient(enemy.x, enemy.y, 0, enemy.x, enemy.y, enemy.radius);
                gradient.addColorStop(0, enemy.color);
                gradient.addColorStop(1, darkenColor(enemy.color, 0.3));
                
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(enemy.x + 2, enemy.y + enemy.radius + 2, enemy.radius * 0.8, enemy.radius * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Main body
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = lightenColor(enemy.color, 0.3);
                ctx.beginPath();
                ctx.arc(enemy.x - enemy.radius * 0.3, enemy.y - enemy.radius * 0.3, enemy.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // HP Bar
                const hpBarWidth = enemy.radius * 2;
                const hpBarHeight = 5;
                const hpBarX = enemy.x - enemy.radius;
                const hpBarY = enemy.y - enemy.radius - 8;
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                const hpPercent = enemy.currentHp / enemy.hp;
                ctx.fillStyle = hpPercent > 0.5 ? '#22c55e' : (hpPercent > 0.2 ? '#f59e0b' : '#ef4444');
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpPercent, hpBarHeight);
            });
        }
        
        function createDeathParticles(x, y, color, radius) {
            const particleCount = Math.max(8, Math.floor(radius * 2));
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 3,
                    color: color
                });
            }
        }
        
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.life -= p.decay * deltaTime;
                p.vy += 0.2 * deltaTime; // Gravity
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }
        
        function darkenColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - amount));
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - amount));
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - amount));
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }
        
        function lightenColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.min(255, parseInt(hex.substr(0, 2), 16) + (255 * amount));
            const g = Math.min(255, parseInt(hex.substr(2, 2), 16) + (255 * amount));
            const b = Math.min(255, parseInt(hex.substr(4, 2), 16) + (255 * amount));
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        function drawTurrets() {
            turrets.forEach(turret => {
                const stats = getTurretStats(turret.type, turret.level);
                const x = turret.x; const y = turret.y;
                
                // Draw range circle (only when selected or placing)
                if (turret === selectedTurret) {
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)';
                    ctx.lineWidth = 2; 
                    ctx.beginPath();
                    ctx.arc(x, y, stats.range, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                }

                // Draw selection circle if this turret is selected
                if (turret === selectedTurret) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, 16, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Pulsing effect
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 18, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw turret base with gradient
                const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
                baseGradient.addColorStop(0, lightenColor(stats.color, 0.2));
                baseGradient.addColorStop(1, stats.color);
                ctx.fillStyle = baseGradient;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Base border
                ctx.strokeStyle = darkenColor(stats.color, 0.3);
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw turret gun with better detail
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(turret.angle);
                
                // Gun shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(2, 1, 18, 6);
                
                // Gun body
                const gunGradient = ctx.createLinearGradient(0, -3, 0, 3);
                gunGradient.addColorStop(0, '#cbd5e1');
                gunGradient.addColorStop(1, '#64748b');
                ctx.fillStyle = gunGradient;
                ctx.fillRect(0, -3, 18, 6);
                
                // Gun tip
                ctx.fillStyle = '#475569';
                ctx.fillRect(16, -2, 4, 4);
                
                ctx.restore();

                // Draw level pips with glow
                const pipCount = turret.level;
                const pipRadius = 3;
                const pipSpacing = 6;
                const totalPipWidth = (pipCount - 1) * pipSpacing;
                const startX = x - totalPipWidth / 2;
                const yOffset = 18;
                for (let i = 0; i < pipCount; i++) {
                    const pipX = startX + i * pipSpacing;
                    // Glow
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#f59e0b';
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(pipX, y + yOffset, pipRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        function drawProjectiles() {
            projectiles.forEach(p => {
                // Glow effect
                ctx.shadowBlur = 8;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.shadowBlur = 0;
                ctx.fillStyle = lightenColor(p.color, 0.5);
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawGhostTower() {
            if (!selectedTowerType) return;
            const stats = getTurretStats(selectedTowerType, 1); // Ghost is always Lvl 1
            const validPlacement = isPlacementValid(mouse.x, mouse.y, stats.cost);
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = validPlacement ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 0, 0, 0.2)';
            ctx.beginPath(); ctx.arc(mouse.x, mouse.y, stats.range, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = stats.color;
            ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 12, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        // === EVENT HANDLERS ===
        
        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        }

        function onMouseClick(e) {
            // Priority 1: Placing a new tower
            if (selectedTowerType) {
                const stats = getTurretStats(selectedTowerType, 1);
                if (isPlacementValid(mouse.x, mouse.y, stats.cost)) {
                    money -= stats.cost;
                    turrets.push({ x: mouse.x, y: mouse.y, type: selectedTowerType, level: 1, cooldown: 0, angle: 0 });
                    updateInGameUI();
                    selectTower(null); // Deselect build mode
                } else {
                    console.log('Invalid placement');
                    selectTower(null); // Deselect build mode
                }
                return; // Action taken
            }
            
            // Priority 2: Check if we clicked on an existing turret
            const clickedTurret = turrets.find(t => Math.hypot(mouse.x - t.x, mouse.y - t.y) < 12);
            if (clickedTurret) {
                if (selectedTurret === clickedTurret) {
                    // Clicked same turret, close menu
                    closeTurretMenu();
                } else {
                    // Clicked a different turret
                    selectedTurret = clickedTurret;
                    openTurretMenu(clickedTurret);
                }
                return; // Action taken
            }

            // Priority 3: Clicked on empty space
            // If we're not building and didn't click a turret, close any open menus
            selectTower(null); // Close build mode
            closeTurretMenu(); // Close upgrade menu
        }
        
        function selectTower(type) {
            if (type) {
                closeTurretMenu(); // Can't have both open
            }
            selectedTowerType = type;
            // Update button styles
            document.querySelectorAll('.tower-button').forEach(btn => {
                if (type && btn.id === `buy-${type}`) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        // === NEW TURRET MENU FUNCTIONS ===
        
        function openTurretMenu(turret) {
            selectedTurret = turret;
            const stats = getTurretStats(turret.type, turret.level);
            
            // 1. Set Title and Stats
            turretMenuTitle.textContent = `${stats.name} (Level ${turret.level})`;
            turretMenuStats.innerHTML = `
                <p>Damage: <span class="font-bold text-white">${stats.damage}</span></p>
                <p>Range: <span class="font-bold text-white">${stats.range}</span></p>
                <p>Rate: <span class="font-bold text-white">${stats.fireRate}</span></p>
            `;
            
            // 2. Show Upgrade Preview if upgrade available
            const maxLevel = playerData.turretMaxLevels[turret.type];
            if (turret.level < maxLevel && stats.nextUpgradeCost) {
                const nextStats = getTurretStats(turret.type, turret.level + 1);
                const dmgDiff = nextStats.damage - stats.damage;
                const rangeDiff = nextStats.range - stats.range;
                const rateDiff = nextStats.fireRate - stats.fireRate;
                
                turretMenuUpgradePreview.innerHTML = `
                    <p class="text-purple-300 font-semibold mb-1">Next Level:</p>
                    ${dmgDiff > 0 ? `<p>DMG: <span class="text-green-400">${stats.damage}  ${nextStats.damage} (+${dmgDiff})</span></p>` : ''}
                    ${rangeDiff > 0 ? `<p>Range: <span class="text-blue-400">${stats.range}  ${nextStats.range} (+${rangeDiff})</span></p>` : ''}
                    ${rateDiff !== 0 ? `<p>Rate: <span class="${rateDiff < 0 ? 'text-yellow-400' : 'text-red-400'}">${stats.fireRate}  ${nextStats.fireRate} (${rateDiff < 0 ? 'faster' : 'slower'})</span></p>` : ''}
                `;
                turretMenuUpgradePreview.style.display = 'block';
            } else {
                turretMenuUpgradePreview.style.display = 'none';
            }
            
            // 3. Configure Upgrade Button
            if (turret.level >= maxLevel) {
                turretMenuUpgrade.textContent = 'Max Level';
                turretMenuUpgrade.disabled = true;
                turretMenuUpgrade.className = 'flex-1 game-button bg-gray-600 cursor-not-allowed';
            } else {
                const upgradeCost = stats.nextUpgradeCost;
                turretMenuUpgrade.textContent = `Upgrade ($${upgradeCost})`;
                if (money >= upgradeCost) {
                    turretMenuUpgrade.disabled = false;
                    turretMenuUpgrade.className = 'flex-1 game-button bg-green-600 hover:bg-green-700';
                } else {
                    turretMenuUpgrade.disabled = true;
                    turretMenuUpgrade.className = 'flex-1 game-button bg-red-700 cursor-not-allowed';
                }
            }

            // 4. Configure Sell Button
            turretMenuSell.textContent = `Sell ($${stats.sellValue})`;
            
            // 4. Position and Show Menu
            // Convert canvas coords to screen coords
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;

            // Position relative to the canvas's container
            let menuLeft = (turret.x * scaleX);
            let menuTop = (turret.y * scaleY);

            // Offset menu to not cover turret
            // And prevent going off-screen
            const menuWidth = 256; // w-64
            const menuHeight = 160; // Approx
            
            if (menuLeft + menuWidth + 20 > rect.width) {
                menuLeft -= (menuWidth + 30); // Show on left
            } else {
                menuLeft += 30; // Show on right
            }
            
            if (menuTop + menuHeight > rect.height) {
                menuTop = rect.height - menuHeight - 10;
            }

            turretMenu.style.left = `${Math.max(0, menuLeft)}px`;
            turretMenu.style.top = `${Math.max(0, menuTop)}px`;
            turretMenu.style.display = 'block';
        }

        function closeTurretMenu() {
            if (selectedTurret) {
                selectedTurret = null;
            }
            if (turretMenu) { // Check if it exists yet
                turretMenu.style.display = 'none';
            }
        }

        function upgradeSelectedTurret() {
            if (!selectedTurret) return;
            
            const stats = getTurretStats(selectedTurret.type, selectedTurret.level);
            const upgradeCost = stats.nextUpgradeCost;
            const maxLevel = playerData.turretMaxLevels[selectedTurret.type];

            if (money >= upgradeCost && selectedTurret.level < maxLevel) {
                money -= upgradeCost;
                selectedTurret.level++;
                updateInGameUI();
                openTurretMenu(selectedTurret); // Refresh menu
            }
        }

        function sellSelectedTurret() {
            if (!selectedTurret) return;
            
            const stats = getTurretStats(selectedTurret.type, selectedTurret.level);
            money += stats.sellValue;
            
            // Remove turret from array
            turrets = turrets.filter(t => t !== selectedTurret);
            
            updateInGameUI();
            closeTurretMenu();
        }

        // === UTILITY & GAME STATE ===

        function isPlacementValid(x, y, cost) {
            if (money < cost) return false;
            for (const t of turrets) {
                if (Math.hypot(x - t.x, y - t.y) < 24) return false;
            }
            if (!currentPath) return false;
            for (let i = 0; i < currentPath.length - 1; i++) {
                if (isPointNearLineSegment(x, y, currentPath[i].x, currentPath[i].y, currentPath[i+1].x, currentPath[i+1].y, pathWidth / 2 + 12)) {
                    return false;
                }
            }
            return true;
        }

        function isPointNearLineSegment(px, py, x1, y1, x2, y2, maxDist) {
            const L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (L2 === 0) return Math.hypot(px - x1, py - y1) < maxDist;
            const t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
            const tClamped = Math.max(0, Math.min(1, t));
            const nearX = x1 + tClamped * (x2 - x1);
            const nearY = y1 + tClamped * (y2 - y1);
            return Math.hypot(px - nearX, py - nearY) < maxDist;
        }

        function updateInGameUI() {
            moneyDisplay.textContent = money;
            livesDisplay.textContent = lives;
            levelDisplay.textContent = currentLevel + 1;
            waveDisplay.textContent = currentWave + (gameState === 'playing' ? 1 : 0);
        }
        
        function endWave() {
            if (gameState !== 'playing') return;
            
            gameState = 'waiting';
            currentWave++;
            startWaveBtn.disabled = false;
            
            if (currentWave >= levels[currentLevel].waves.length) {
                showLevelComplete();
            } else {
                startWaveBtn.textContent = 'Start Wave';
                updateInGameUI();
            }
        }

        function checkGameOver() {
            if (lives <= 0) {
                lives = 0;
                updateInGameUI();
                gameState = 'gameover';
                closeTurretMenu();
                messageTitle.textContent = 'Game Over!';
                messageText.textContent = `You ran out of base HP on level ${currentLevel + 1}, wave ${currentWave + 1}.`;
                
                messageButton1.textContent = 'Restart Level';
                messageButton1.onclick = () => {
                    messageBox.style.display = 'none';
                    loadLevel(currentLevel); // Restart current level
                    gameLoopId = requestAnimationFrame(gameLoop); // Restart loop
                };
                
                messageButton2.textContent = 'Main Menu';
                messageButton2.onclick = () => {
                    showMainMenu();
                };
                messageBox.style.display = 'block';
            }
        }
        
        function showLevelComplete() {
            gameState = 'win';
            closeTurretMenu();
            const reward = levels[currentLevel].gemReward || 0;
            playerData.gems += reward;
            
            // Update menu UI in background so gem count is correct when player returns
            updateMenuUI(); 

            messageTitle.textContent = 'Level Complete!';
            messageText.textContent = `You beat level ${currentLevel + 1}! You earned ${reward} gems.`;
            
            messageButton1.textContent = 'Next Level';
            const nextLevel = currentLevel + 1;
            
            if (levels[nextLevel]) {
                messageButton1.disabled = false;
                messageButton1.onclick = () => {
                    messageBox.style.display = 'none';
                    startGame(nextLevel); // Start next level
                };
            } else {
                messageButton1.textContent = 'All Levels Beat!';
                messageButton1.disabled = true;
            }
            
            messageButton2.textContent = 'Main Menu';
            messageButton2.onclick = () => {
                showMainMenu();
            };
            messageBox.style.display = 'block';
        }

        // --- This line starts the entire application ---
        window.addEventListener('DOMContentLoaded', init);

    </script>
</head>
<body class="bg-gray-900 text-gray-200 h-screen flex items-center justify-center p-4">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 text-white flex items-center justify-center z-50">
        <div class="text-2xl font-bold">Loading Game...</div>
    </div>

    <!-- Start Menu -->
    <div id="start-menu" class="fixed inset-0 bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 flex flex-col items-center justify-center z-40">
        <div class="text-center mb-8">
            <h1 class="text-6xl font-bold text-white mb-4 drop-shadow-2xl" style="text-shadow: 0 0 20px rgba(147, 51, 234, 0.8);">TOWER DEFENSE</h1>
            <div class="text-xl text-gray-300 mb-8">Defend your base from waves of enemies</div>
            <div class="text-lg font-semibold bg-purple-900 bg-opacity-50 px-6 py-3 rounded-lg inline-block mb-8">
                Gems: <span id="gem-display-start" class="text-purple-300 font-bold">0</span>
            </div>
        </div>
        <button id="start-play-btn" class="game-button bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white font-bold text-2xl py-4 px-12 rounded-xl shadow-2xl transform transition-all duration-200 hover:scale-105">
            PLAY
        </button>
    </div>

    <!-- Main Menu (Level Select & Armory) -->
    <div id="main-menu" class="hidden fixed inset-0 bg-gray-900 z-30">
        <!-- Top Bar -->
        <div class="bg-gray-800 border-b border-gray-700 p-4 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-white">Tower Defense</h1>
            <div class="flex items-center space-x-4">
                <div class="text-lg font-semibold bg-gray-700 px-4 py-2 rounded-lg">
                    Gems: <span id="gem-display" class="text-purple-400 font-bold">0</span>
                </div>
                <button id="back-to-start-btn" class="game-button bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">Back</button>
            </div>
        </div>
        
        <!-- Navigation Tabs -->
        <div class="bg-gray-800 border-b border-gray-700 flex">
            <button id="nav-levels" class="flex-1 py-4 px-6 text-lg font-semibold bg-blue-600 text-white">Levels</button>
            <button id="nav-armory" class="flex-1 py-4 px-6 text-lg font-semibold bg-gray-700 hover:bg-gray-600 text-gray-300">Armory</button>
        </div>
        
        <!-- Level Select View -->
        <div id="level-select-view" class="flex-1 overflow-hidden relative">
            <button id="level-nav-left" class="absolute left-4 top-1/2 -translate-y-1/2 z-10 bg-gray-800 hover:bg-gray-700 text-white text-4xl font-bold w-16 h-16 rounded-full flex items-center justify-center shadow-lg"></button>
            <div id="level-select-container" class="flex overflow-x-auto scrollbar-hide snap-x snap-mandatory h-full items-center px-20">
                <!-- Level cards will be injected here -->
            </div>
            <button id="level-nav-right" class="absolute right-4 top-1/2 -translate-y-1/2 z-10 bg-gray-800 hover:bg-gray-700 text-white text-4xl font-bold w-16 h-16 rounded-full flex items-center justify-center shadow-lg"></button>
        </div>
        
        <!-- Armory View -->
        <div id="armory-view" class="hidden flex-1 overflow-y-auto p-6">
            <div id="armory-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <!-- Turret cards will be injected here -->
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="hidden fixed inset-0 bg-gray-900 flex flex-col">
        <!-- Top Game UI Bar -->
        <div class="bg-gray-800 p-3 flex justify-between items-center flex-shrink-0">
            <div class="flex space-x-4 text-sm md:text-base">
                <div>Money: <span id="money-display" class="font-bold text-green-400">0</span></div>
                <div>Base HP: <span id="lives-display" class="font-bold text-red-400">0</span></div>
            </div>
            <div class="flex space-x-4 text-center text-sm md:text-base">
                <div>Level: <span id="level-display" class="font-bold text-blue-300">1</span></div>
                <div>Wave: <span id="wave-display" class="font-bold text-yellow-300">0</span></div>
            </div>
            <div class="flex space-x-2">
                <button id="start-wave-btn" class="game-button bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 text-sm rounded-lg">Start Wave</button>
                <button id="back-to-menu-btn" class="game-button bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 text-sm rounded-lg">Menu</button>
            </div>
        </div>

        <!-- Canvas Container (Handles Aspect Ratio AND Turret Menu) -->
        <div id="game-canvas-container" class="bg-gray-700 flex-1 flex items-center justify-center min-h-0">
            <canvas id="game-canvas"></canvas>

            <!-- Enhanced Turret Upgrade Menu -->
            <div id="turret-menu" class="hidden absolute bg-gray-800 rounded-lg shadow-xl p-4 w-72 text-gray-300 border-2 border-blue-500 z-20">
                <h3 id="turret-menu-title" class="text-xl font-bold mb-2 text-white">Turret</h3>
                <div id="turret-menu-stats" class="text-sm space-y-1 mb-3">
                    <!-- Stats injected here -->
                </div>
                <div id="turret-menu-upgrade-preview" class="text-xs text-gray-400 mb-3 border-t border-gray-700 pt-2">
                    <!-- Upgrade preview injected here -->
                </div>
                <div class="flex space-x-2">
                    <button id="turret-menu-upgrade" class="flex-1 game-button bg-green-600 hover:bg-green-700">Upgrade</button>
                    <button id="turret-menu-sell" class="flex-1 game-button bg-red-600 hover:bg-red-700">Sell</button>
                </div>
                <button id="turret-menu-close" class="absolute -top-3 -right-3 text-gray-200 bg-red-600 hover:bg-red-700 w-7 h-7 rounded-full font-bold text-lg flex items-center justify-center border-2 border-white">&times;</button>
            </div>
        </div>

        <!-- Bottom Tower Selection Bar -->
        <div id="tower-selection-ui" class="bg-gray-800 p-2 flex space-x-2 justify-center overflow-x-auto flex-shrink-0">
            <!-- Tower buttons will be injected here -->
        </div>
    </div>

    <!-- Message Box (Game Over / Win) -->
    <div id="message-box" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-40">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center w-full max-w-md">
            <h2 id="message-title" class="text-3xl font-bold mb-4">Game Over!</h2>
            <p id="message-text" class="text-lg mb-6">You lost.</p>
            <div class="flex justify-center space-x-4">
                <button id="message-button-1" class="game-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg">Restart</button>
                <button id="message-button-2" class="game-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-lg">Main Menu</button>
            </div>
        </div>
    </div>

    <!-- Debug Menu (Press 'D' to toggle) -->
    <div id="debug-menu" class="hidden fixed top-4 right-4 bg-yellow-900 bg-opacity-95 border-2 border-yellow-500 rounded-lg shadow-2xl p-4 z-50 min-w-[250px]">
        <div class="flex justify-between items-center mb-3">
            <h3 class="text-lg font-bold text-yellow-200">Debug Menu</h3>
            <button id="debug-close" class="text-yellow-200 hover:text-white font-bold text-xl">&times;</button>
        </div>
        <div class="space-y-2 text-sm">
            <div class="text-yellow-300 mb-2">Press 'D' to toggle</div>
            <button id="debug-add-gems" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">+100 Gems</button>
            <button id="debug-add-money" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">+1000 Money</button>
            <button id="debug-unlock-all" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">Unlock All Turrets</button>
            <button id="debug-max-all" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">Max All Turret Levels</button>
            <button id="debug-add-lives" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">+10 Lives</button>
        </div>
    </div>

</body>
</html>
