<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense (Upgrades)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Using Inter font, as it's a nice default included with Tailwind */
        body { font-family: 'Inter', sans-serif; }
        
        /* Add a visual cue for the selected tower */
        .tower-button.selected {
            border-color: #3b82f6 !important; /* blue-500 */
            box-shadow: 0 0 10px #3b82f6;
        }
        
        /* Base button style for consistent hover/active states */
        .game-button {
            transition: all 0.1s ease-in-out;
        }
        .game-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .game-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: none;
        }
        
        /* Hide scrollbars but keep functionality */
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        
        /* This container is crucial. It holds the canvas and gives it a 
          responsive 4:3 aspect ratio, which our resizeCanvas() function uses.
        */
        #game-canvas-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: calc(100vw - 320px); /* Account for sidebar width */
            max-height: calc(100vh - 100px); /* Account for UI elements */
            aspect-ratio: 4 / 3;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas {
            display: block;
            background-color: #374151; /* gray-700, to see the game area */
            /* Positioning is handled dynamically by resizeCanvas function */
        }
        
        /* Game container should fit viewport */
        #game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            max-width: 100vw;
            position: relative; /* For absolute positioning of centered canvas */
        }
        
        /* Level select cards */
        .level-card {
            min-width: 300px;
            max-width: 400px;
            scroll-snap-align: center;
        }

        /* Compact and ultra-compact modes for level cards */
        .level-card-compact .typography-title { font-size: clamp(16px, 1.8vw, 22px); }
        .level-card-compact .typography-metric { font-size: clamp(14px, 1.8vw, 20px); }
        .level-card-compact .typography-desc { font-size: clamp(11px, 1.2vw, 14px); }
        .level-card-compact .card-pad { padding: clamp(8px, 1.1vw, 14px); }
        .level-card-compact .grid { gap: 0.5rem; }

        .level-card-ultra .level-card-metrics { display: none; }
        .level-card-ultra .level-status-icon { display: none; }
        .level-card-ultra .typography-title { font-size: clamp(18px, 2vw, 24px); }
        
        /* === NEW UI/UX IMPROVEMENTS === */
        
        /* Smooth menu transitions */
        .menu-transition {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .menu-fade-enter {
            opacity: 0;
            transform: translateY(20px);
        }
        
        .menu-fade-enter-active {
            opacity: 1;
            transform: translateY(0);
        }
        
        .menu-slide-enter {
            opacity: 0;
            transform: translateX(-100%);
        }
        
        .menu-slide-enter-active {
            opacity: 1;
            transform: translateX(0);
        }
        
        /* Enhanced gameplay area */
        #game-canvas-container.expanded {
            max-width: 95vw;
            max-height: 80vh;
            margin: 0 auto;
        }
        
        /* Improved menu layout */
        .menu-header {
            background: linear-gradient(135deg, #1f2937 0%, #374151 100%);
            border-bottom: 2px solid #4b5563;
        }
        
        .menu-content {
            background: linear-gradient(135deg, #111827 0%, #1f2937 100%);
        }
        
        /* Level-specific color schemes */
        .level-theme-forest {
            --path-color: #8b4513;
            --path-texture: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><rect width="20" height="20" fill="%23d2b48c"/><circle cx="5" cy="5" r="1" fill="%23a0522d"/><circle cx="15" cy="15" r="1" fill="%23a0522d"/></svg>');
        }
        
        .level-theme-desert {
            --path-color: #daa520;
            --path-texture: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><rect width="20" height="20" fill="%23f4a460"/><circle cx="3" cy="3" r="0.5" fill="%23d2691e"/><circle cx="17" cy="17" r="0.5" fill="%23d2691e"/></svg>');
        }
        
        .level-theme-snow {
            --path-color: #e0e0e0;
            --path-texture: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><rect width="20" height="20" fill="%23f0f8ff"/><circle cx="10" cy="10" r="2" fill="%23b0e0e6" opacity="0.3"/></svg>');
        }
        
        .level-theme-volcanic {
            --path-color: #8b0000;
            --path-texture: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><rect width="20" height="20" fill="%23a52a2a"/><circle cx="7" cy="7" r="1" fill="%23ff4500"/><circle cx="13" cy="13" r="1" fill="%23ff6347"/></svg>');
        }
        
        /* Responsive design improvements */
        @media (max-width: 1024px) {
            #armory-sidebar {
                width: 16rem; /* Reduce sidebar width on smaller screens */
            }
            #game-canvas-container {
                max-width: calc(100vw - 16rem - 20px); /* Account for reduced sidebar */
            }
        }
        
        @media (max-width: 768px) {
            #armory-sidebar {
                width: 14rem; /* Further reduce sidebar width */
            }
            #game-canvas-container {
                max-width: calc(100vw - 14rem - 20px);
                max-height: 70vh;
            }
            #game-canvas-container.expanded {
                max-width: 100vw;
                max-height: 70vh;
            }
            .level-card {
                min-width: 250px;
                max-width: 300px;
            }
        }
        
        @media (max-width: 640px) {
            /* Mobile layout - stack sidebar on top */
            #main-menu > .flex {
                flex-direction: column;
            }
            #armory-sidebar {
                width: 100%;
                height: 40vh; /* Take up top portion */
                border-right: none;
                border-bottom: 1px solid #374151;
            }
            #game-canvas-container {
                max-width: 95vw;
                max-height: 60vh;
                position: relative; /* Reset positioning for mobile */
                transform: none;
                top: auto;
                left: auto;
            }
            .level-card {
                min-width: 200px;
                max-width: 250px;
            }
        }

        /* --- Responsive Typography and Spacing --- */
        /* Scales typography using viewport while enforcing readable minimums */
        .typography-title { font-size: clamp(18px, 2.2vw, 28px); line-height: 1.2; }
        .typography-desc { font-size: clamp(12px, 1.5vw, 16px); line-height: 1.45; }
        .typography-metric { font-size: clamp(16px, 2.2vw, 24px); line-height: 1.3; }
        .typography-button { font-size: clamp(14px, 1.9vw, 18px); }
        .icon-lg { font-size: clamp(22px, 2.6vw, 32px); }
        .icon-md { font-size: clamp(16px, 2.0vw, 24px); }

        /* Scales card padding and gaps to preserve content visibility */
        .card-pad { padding: clamp(10px, 1.4vw, 18px); }
        .card-gap { gap: clamp(8px, 1.2vw, 16px); }
        .section-margin { margin-bottom: clamp(12px, 1.8vw, 24px); }
        .btn-min { min-height: 48px; min-width: 48px; }

        /* Themed scrollbar to match site aesthetics */
        .scrollbar-themed {
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: #6b21a8 #1f2937; /* thumb track */
        }
        .scrollbar-themed::-webkit-scrollbar { width: 10px; height: 10px; }
        .scrollbar-themed::-webkit-scrollbar-track { background: #1f2937; border-radius: 9999px; }
        .scrollbar-themed::-webkit-scrollbar-thumb { background: linear-gradient(180deg, #7c3aed, #6b21a8); border-radius: 9999px; border: 2px solid #111827; }
        .scrollbar-themed::-webkit-scrollbar-thumb:hover { background: linear-gradient(180deg, #8b5cf6, #7c3aed); }
    </style>
    
    <script type="module">
        // === GAME SETUP ===
        
        // Local game state
        let gameLoopId = null; // To stop the game loop
        let updateLogs = []; // To store update logs from CSV

        // --- UI Elements ---
        // These will be assigned in init() after the page loads
        let loadingOverlay, startMenu, mainMenu, gameContainer, levelSelectContainer, armoryContainer, gemDisplay, gemDisplayStart, gemDisplayMenu;
        let navLevels, navArmory, levelSelectView, armoryView, levelNavLeft, levelNavRight, backToStartBtn, startPlayBtn;
        let canvas, ctx, moneyDisplay, livesDisplay, levelDisplay, waveDisplay, startWaveBtn, towerSelectionUI, backToMenuBtn, speedDownBtn, speedUpBtn, speedDisplay;
        let armoryToggleBtn, armorySection, armoryCloseBtn;
        let messageBox, messageTitle, messageText, messageButton1, messageButton2;
        // --- NEW UPGRADE UI ELEMENTS ---
        let turretMenu, turretMenuTitle, turretMenuStats, turretMenuUpgrade, turretMenuSell, turretMenuClose, turretMenuUpgradePreview;
        
        // --- DEBUG MENU ELEMENTS ---
        let debugMenu, debugClose, debugAddGems, debugAddMoney, debugUnlockAll, debugMaxAll, debugAddLives;

        let canvasWidth, canvasHeight;

        // Game State (In-Level)
        let money = 0;
        let lives = 0; // This is 'Base HP'
        let currentLevel = 0;
        let currentWave = 0;
        let gameState = 'waiting'; // 'waiting', 'playing', 'gameover', 'win'
        let selectedTowerType = null; // e.g., 'basic' (for building)
        let selectedTurret = null; // The actual turret object on the map (for upgrading)
        let mouse = { x: 0, y: 0 };
        let lastTime = 0;
        let gameSpeed = 1; // gameplay speed multiplier, clamped 1x‚Äì8x
        // --- Level stats tracking ---
        let enemiesDefeated = 0;
        let moneyEarned = 0;
        let turretsPlaced = 0;
        let elapsedTimeMs = 0;

        // Game Objects (In-Level)
        let turrets = [];
        let enemies = [];
        let projectiles = [];
        let particles = []; // For visual effects
        let spawnQueue = [];
        let spawnCounter = 0;
        let currentPath = []; // Will be set when level loads
        const pathWidth = 30;
        
        // --- Save System ---
        const SAVE_SLOT_KEY = 'td_save_slot';
        const SAVE_PREFIX = 'td_save_'; // e.g., td_save_1..4

        function getDefaultPlayerData(turretTypes) {
            const turretMaxLevels = {};
            Object.keys(turretTypes || {}).forEach(id => {
                turretMaxLevels[id] = id === 'basic' ? 1 : 0;
            });
            return {
                gems: 10,
                turretMaxLevels,
                completedLevels: [],
                settings: { audioEnabled: true, musicEnabled: true }
            };
        }

        function getActiveSlot() {
            const slot = parseInt(localStorage.getItem(SAVE_SLOT_KEY) || '1', 10);
            return Math.min(Math.max(slot || 1, 1), 4);
        }

        function setActiveSlot(slot) {
            localStorage.setItem(SAVE_SLOT_KEY, String(slot));
        }

        function saveToSlot(slot, data) {
            try { localStorage.setItem(`${SAVE_PREFIX}${slot}`, JSON.stringify(data)); } catch {}
        }

        function loadFromSlot(slot) {
            const raw = localStorage.getItem(`${SAVE_PREFIX}${slot}`);
            if (!raw) return null;
            try { return JSON.parse(raw); } catch { return null; }
        }

        function mergeDataWithDefaults(loaded, turretTypes) {
            const defaults = getDefaultPlayerData(turretTypes);
            const data = loaded || {};
            return {
                gems: typeof data.gems === 'number' ? data.gems : defaults.gems,
                turretMaxLevels: { ...defaults.turretMaxLevels, ...(data.turretMaxLevels || {}) },
                completedLevels: Array.isArray(data.completedLevels) ? data.completedLevels : defaults.completedLevels,
                settings: { ...defaults.settings, ...(data.settings || {}) }
            };
        }

        function saveProgress() {
            const slot = getActiveSlot();
            saveToSlot(slot, playerData);
        }

        function switchSaveSlot(slot, turretTypes) {
            setActiveSlot(slot);
            const loaded = loadFromSlot(slot);
            playerData = mergeDataWithDefaults(loaded, turretTypes);
            saveProgress();
            updateMenuUI();
        }

        function clearSaveSlot(slot, turretTypes) {
            localStorage.removeItem(`${SAVE_PREFIX}${slot}`);
            playerData = getDefaultPlayerData(turretTypes);
            setActiveSlot(slot);
            saveProgress();
            updateMenuUI();
        }

        // --- Player's Data (initial value; will be replaced by loaded save) ---
        // NEW DATA STRUCTURE:
        // 0 = Locked
        // 1 = Unlocked (Base Level 1)
        // 2 = Max Level 2
        // 3 = Max Level 3
        let playerData = {
            gems: 10,
            turretMaxLevels: {
                'basic': 1,
                'sniper': 0,
                'flamethrower': 0
            },
            completedLevels: [],
            settings: { audioEnabled: true, musicEnabled: true }
        };


        // === GAME DATA ===
        // These will be loaded from CSV files
        let turretTypes = {};
        let enemyTypes = {};
        let levels = [];

        // === CSV PARSING FUNCTIONS ===

        async function loadCSV(filename) {
            try {
                // Add cache-busting parameter to ensure fresh data
                const cacheBuster = `?v=${Date.now()}`;
                const response = await fetch(filename + cacheBuster);
                if (!response.ok) {
                    throw new Error(`Failed to load ${filename}: ${response.status} ${response.statusText}`);
                }
                const text = await response.text();
                if (!text || text.trim().length === 0) {
                    throw new Error(`${filename} is empty or could not be read`);
                }
                return text;
            } catch (error) {
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    throw new Error(`Cannot load ${filename}. This usually means you're opening the file directly. Please use a local web server.`);
                }
                throw error;
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            const headers = lines[0].split(',');
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                const row = {};
                headers.forEach((header, index) => {
                    row[header.trim()] = values[index] !== undefined ? values[index].trim() : '';
                });
                data.push(row);
            }
            
            return data;
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current);
            
            return values;
        }

        function parsePath(pathString) {
            // Path format: "x1,y1|x2,y2|x3,y3"
            const points = pathString.split('|');
            return points.map(point => {
                const [x, y] = point.split(',');
                return { x: parseFloat(x), y: parseFloat(y) };
            });
        }

        function parseArray(arrayString) {
            // Array format: "val1|val2|val3"
            if (!arrayString) return [];
            return arrayString.split('|').map(val => parseFloat(val.trim())).filter(val => !isNaN(val));
        }

        function parseEnemies(enemiesString) {
            // Format: "type1:count1:spawnRate1:delay1+type2:count2:spawnRate2:delay2"
            const groups = enemiesString.split('+');
            return groups.map(group => {
                const parts = group.split(':');
                const enemy = {
                    type: parts[0].trim(),
                    count: parseInt(parts[1]) || 0,
                    spawnRate: parseInt(parts[2]) || 60
                };
                if (parts[3]) {
                    enemy.delay = parseInt(parts[3]);
                }
                return enemy;
            });
        }

        async function loadGameData() {
            try {
                // Check if we're running from file:// protocol (which doesn't support fetch)
                if (window.location.protocol === 'file:') {
                    throw new Error('Cannot load CSV files from file:// protocol. Please use a local web server (e.g., python -m http.server or live-server).');
                }
                
                // Load enemies
                const enemiesCSV = await loadCSV('enemies.csv');
                const enemiesData = parseCSV(enemiesCSV);
                enemyTypes = {};
                enemiesData.forEach(row => {
                    enemyTypes[row.id] = {
                        hp: parseFloat(row.hp),
                        speed: parseFloat(row.speed),
                        reward: parseFloat(row.reward),
                        damage: parseFloat(row.damage),
                        color: row.color,
                        radius: parseFloat(row.radius)
                    };
                });

                // Load turrets
                const turretsCSV = await loadCSV('turrets.csv');
                const turretsLines = turretsCSV.trim().split('\n');
                const headers = turretsLines[0].split(',').map(h => h.trim());
                turretTypes = {};
                
                // Parse turrets manually to handle empty column
                // Column structure: id, name, cost, damage, range, fireRate, projectileColor, projectileSpeed, 
                // color, description, gemUnlockCost, inGameUpgradeCost (actually gemUpgradeCost), 
                // empty, inGameUpgradeCost (no header), damageUpgrade, rangeUpgrade, fireRateUpgrade
                for (let i = 1; i < turretsLines.length; i++) {
                    const rowValues = parseCSVLine(turretsLines[i]);
                    const row = {};
                    headers.forEach((header, index) => {
                        if (header) { // Skip empty header columns
                            row[header] = rowValues[index] !== undefined ? rowValues[index].trim() : '';
                        }
                    });
                    
                    const id = row.id.toLowerCase();
                    // Find indices: gemUpgradeCost is at index of 'inGameUpgradeCost' header (11)
                    // inGameUpgradeCost is at index 12 (right after the 'inGameUpgradeCost' header column)
                    const gemUpgradeCostIndex = headers.indexOf('inGameUpgradeCost'); // Should be 11
                    const inGameUpgradeCostIndex = gemUpgradeCostIndex + 1; // Next column after gemUpgradeCost
                    
                    const gemUpgradeCostArray = parseArray(rowValues[gemUpgradeCostIndex] || '');
                    const inGameUpgradeCostArray = parseArray(rowValues[inGameUpgradeCostIndex] || '');
                    
                    console.log(`Turret ${id}: gemUpgradeCost=${rowValues[gemUpgradeCostIndex]}, inGameUpgradeCost=${rowValues[inGameUpgradeCostIndex]}`);
                    console.log(`Turret ${id}: parsed gemUpgradeCost=`, gemUpgradeCostArray, `inGameUpgradeCost=`, inGameUpgradeCostArray);
                    
                    turretTypes[id] = {
                        name: row.name,
                        cost: parseFloat(row.cost),
                        damage: parseFloat(row.damage),
                        range: parseFloat(row.range),
                        fireRate: parseFloat(row.fireRate),
                        projectileColor: row.projectileColor,
                        projectileSpeed: parseFloat(row.projectileSpeed),
                        color: row.color,
                        description: row.description,
                        gemUnlockCost: parseFloat(row.gemUnlockCost) || 0,
                        gemUpgradeCost: gemUpgradeCostArray,
                        inGameUpgradeCost: inGameUpgradeCostArray,
                        statUpgrades: {
                            damage: parseFloat(row.damageUpgrade) || 0,
                            range: parseFloat(row.rangeUpgrade) || 0,
                            fireRate: parseFloat(row.fireRateUpgrade) || 0
                        }
                    };
                }

                // Load levels
                const levelsCSV = await loadCSV('levels.csv');
                const levelsLines = levelsCSV.trim().split('\n');
                levels = [];
                
                // Parse levels manually because path contains unquoted commas
                for (let i = 1; i < levelsLines.length; i++) {
                    const line = levelsLines[i];
                    
                    // Find the 5th comma (after gemReward)
                    let commaCount = 0;
                    let pathStartIndex = 0;
                    for (let j = 0; j < line.length; j++) {
                        if (line[j] === ',') {
                            commaCount++;
                            if (commaCount === 5) {
                                pathStartIndex = j + 1;
                                break;
                            }
                        }
                    }
                    
                    // Extract first 5 fields
                    const firstPart = line.substring(0, pathStartIndex - 1);
                    const firstValues = firstPart.split(',');
                    const level = parseInt(firstValues[0]);
                    const startingMoney = parseFloat(firstValues[1]);
                    const startingLives = parseFloat(firstValues[2]);
                    const difficulty = firstValues[3];
                    const gemReward = parseFloat(firstValues[4]);
                    
                    // Extract path (everything after the 5th comma)
                    const pathString = line.substring(pathStartIndex);
                    const parsedPath = parsePath(pathString);
                    
                    console.log(`Level ${level} path string:`, pathString);
                    console.log(`Level ${level} parsed path:`, parsedPath);
                    
                    levels.push({
                        path: parsedPath,
                        startingMoney: startingMoney,
                        startingLives: startingLives,
                        difficulty: difficulty,
                        gemReward: gemReward,
                        waves: [] // Will be populated from waves.csv
                    });
                }

                // Load waves
                const wavesCSV = await loadCSV('waves.csv');
                const wavesData = parseCSV(wavesCSV);
                wavesData.forEach(row => {
                    const levelIndex = parseInt(row.level) - 1;
                    const waveIndex = parseInt(row.wave) - 1;
                    
                    if (!levels[levelIndex]) return;
                    if (!levels[levelIndex].waves[waveIndex]) {
                        levels[levelIndex].waves[waveIndex] = { enemies: [] };
                    }
                    
                    const enemyGroups = parseEnemies(row.enemies);
                    levels[levelIndex].waves[waveIndex].enemies = enemyGroups;
                });

                console.log('Game data loaded successfully');
                return true;
            } catch (error) {
                console.error('Error loading game data:', error);
                console.error('Error details:', error.message, error.stack);
                throw error; // Re-throw to show in UI
            }
        }
        
        // === NEW HELPER FUNCTIONS ===

        /**
         * Calculates the stats of a turret at a specific level.
         * This is the single source of truth for all turret stats.
         */
        function getTurretStats(type, level) {
            const baseStats = turretTypes[type];
            if (!baseStats) return null;

            const calculatedStats = {
                name: baseStats.name,
                color: baseStats.color,
                projectileColor: baseStats.projectileColor,
                projectileSpeed: baseStats.projectileSpeed,
                cost: baseStats.cost, // Base cost is always for Lvl 1
                
                // Calculate stats based on level
                damage: baseStats.damage + (baseStats.statUpgrades.damage * (level - 1)),
                range: baseStats.range + (baseStats.statUpgrades.range * (level - 1)),
                fireRate: Math.max(1, baseStats.fireRate + (baseStats.statUpgrades.fireRate * (level - 1))), // Don't let fireRate be 0 or less
                
                // Calculate total cost (for sell value)
                totalCost: baseStats.cost,
                nextUpgradeCost: null
            };

            // Calculate total spent and cost for next upgrade
            for (let i = 0; i < level - 1; i++) {
                calculatedStats.totalCost += baseStats.inGameUpgradeCost[i] || 0;
            }
            
            // Get cost for the *next* level
            if (level < 10) { // Assume a max level cap for safety
                 calculatedStats.nextUpgradeCost = baseStats.inGameUpgradeCost[level - 1]; // e.g., for Lvl 1, this gets cost to Lvl 2 (index 0)
            }
           
            calculatedStats.sellValue = Math.floor(calculatedStats.totalCost * 0.7);

            return calculatedStats;
        }

        /** Gets a list of turret IDs that are unlocked (max level > 0) */
        function getUnlockedTurrets() {
            return Object.keys(playerData.turretMaxLevels).filter(id => playerData.turretMaxLevels[id] > 0);
        }

        
        // === MAIN MENU & UI LOGIC ===
        
        function showMainMenu() {
            // Add transition effects
            startMenu.classList.add('menu-fade-enter');
            gameContainer.classList.add('menu-fade-enter');
            
            setTimeout(() => {
                // Hide game, show menu
                gameContainer.style.display = 'none';
                startMenu.style.display = 'none';
                messageBox.style.display = 'none';
                
                mainMenu.style.display = 'flex';
                mainMenu.classList.remove('menu-fade-enter');
                mainMenu.classList.add('menu-fade-enter-active');
                closeTurretMenu();
                
                // Stop game loop if it's running
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
                
                // Refresh menu data
                updateMenuUI();
                switchMenuTab('levels'); // Default to levels tab
            }, 150);
        }
        
        function updateMenuUI() {
            if (!playerData) return;
            
            if (gemDisplay) gemDisplay.textContent = playerData.gems || 0;
            if (gemDisplayStart) gemDisplayStart.textContent = playerData.gems || 0;
            if (gemDisplayMenu) gemDisplayMenu.textContent = playerData.gems || 0;
            
            // --- Populate Level Select with enhanced cards (responsive) ---
            levelSelectContainer.innerHTML = ''; // Clear old list
            let currentPage = 0;

            function getGridConfig() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                const landscape = w > h;
                let cols = 3, rows = 2, gap = 6, heightVh = 72;
                if (!landscape) {
                    cols = 2; rows = 2; gap = 4; heightVh = 78;
                } else if (w < 700) {
                    cols = 2; rows = 2; gap = 4; heightVh = 76;
                } else if (w < 900) {
                    cols = 2; rows = 3; gap = 5; heightVh = 74;
                } else if (w < 1200) {
                    cols = 3; rows = 2; gap = 5; heightVh = 72;
                } else {
                    cols = 3; rows = 2; gap = 6; heightVh = 72;
                }
                return { cols, rows, gap, heightVh };
            }

            const paginationBar = document.getElementById('level-pagination');
            function updateNavButtons(totalPagesLocal) {
                levelNavLeft.style.display = currentPage > 0 ? 'flex' : 'none';
                levelNavRight.style.display = currentPage < (totalPagesLocal - 1) ? 'flex' : 'none';
            }

            function renderPage(page) {
                const cfg = getGridConfig();
                const levelsPerPage = cfg.cols * cfg.rows;
                const totalPagesLocal = Math.ceil(levels.length / levelsPerPage);
                currentPage = Math.max(0, Math.min(totalPagesLocal - 1, page));

                // Update container grid and height
                levelSelectContainer.style.height = `${cfg.heightVh}vh`;
                levelSelectContainer.className = `grid grid-cols-${cfg.cols} grid-rows-${cfg.rows} gap-${cfg.gap} place-items-stretch items-stretch w-full h-full border-4 border-purple-500`;
                levelSelectContainer.innerHTML = '';

                const start = currentPage * levelsPerPage;
                const end = Math.min(levels.length, start + levelsPerPage);

                for (let i = start; i < end; i++) {
                    const levelData = levels[i];
                    const levelCard = document.createElement('div');
                    const titleSize = 'typography-title';
                    const iconSize = 'icon-lg';
                    const metricSize = 'typography-metric';
                    const descSize = 'typography-desc';
                    const padCard = 'card-pad';
                    const btnPad = (cfg.rows >= 3 || cfg.cols === 2) ? 'py-3 px-4' : 'py-4 px-6';
                    levelCard.className = `level-card bg-gradient-to-br from-gray-700 via-gray-600 to-gray-700 ${padCard} rounded-xl border border-gray-500 hover:border-yellow-400 transition-all duration-300 hover:shadow-lg hover:shadow-yellow-500/30 cursor-pointer backdrop-blur-sm border-2 border-blue-500 w-full h-auto flex flex-col justify-between`;

                    const isUnlocked = i === 0 || playerData.completedLevels.includes(i - 1);
                    const isCompleted = playerData.completedLevels.includes(i);

                    let buttonText = 'Play Level';
                    let buttonClass = 'bg-gradient-to-r from-blue-600 via-blue-500 to-blue-600 hover:from-blue-700 hover:via-blue-600 hover:to-blue-700 text-white';
                    let buttonDisabled = false;
                    let statusIcon = 'üéÆ';

                    if (isCompleted) {
                        buttonText = 'Replay Level';
                        buttonClass = 'bg-gradient-to-r from-green-600 via-green-500 to-green-600 hover:from-green-700 hover:via-green-600 hover:to-green-700 text-white';
                        statusIcon = 'üèÜ';
                    } else if (!isUnlocked) {
                        buttonText = 'üîí Locked';
                        buttonClass = 'bg-gradient-to-r from-red-900 via-red-800 to-red-900 text-red-300 cursor-not-allowed';
                        buttonDisabled = true;
                        statusIcon = 'üîí';
                    }

                    const difficultyColor = {
                        'Easy': 'text-green-400',
                        'Medium': 'text-yellow-400', 
                        'Hard': 'text-orange-400',
                        'Very Hard': 'text-red-400',
                        'Expert': 'text-purple-400',
                        'Insane': 'text-pink-400'
                    }[levelData.difficulty] || 'text-gray-400';

                    levelCard.innerHTML = `
                        <div class="flex-1 flex flex-col space-y-3">
                            <div class="flex items-center justify-between">
                                <h3 class="typography-title font-bold text-yellow-300">Level ${i + 1}</h3>
                                ${isCompleted ? '<span class="level-status-icon typography-desc text-green-300">üèÜ</span>' : '<span class="level-status-icon typography-desc text-gray-400">üéÆ</span>'}
                            </div>

                        <div class="level-card-metrics grid grid-cols-2 gap-4">
                            <div class="text-center bg-gradient-to-b from-gray-800 via-gray-700 to-gray-800 ${padCard} rounded-lg border border-gray-600 hover:border-yellow-500 transition-all duration-200">
                                <p class="text-gray-400 text-sm mb-2 flex items-center justify-center">
                                    <span class="mr-1">üåä</span>Waves
                                </p>
                                <p class="text-yellow-300 font-bold ${metricSize}">${levelData.waves.length}</p>
                            </div>
                            <div class="text-center bg-gradient-to-b from-gray-800 via-gray-700 to-gray-800 ${padCard} rounded-lg border border-gray-600 hover:border-purple-500 transition-all duration-200">
                                <p class="text-gray-400 text-sm mb-2 flex items-center justify-center">
                                    <span class="mr-1">üíé</span>Reward
                                </p>
                                <p class="text-purple-300 font-bold ${metricSize}">${levelData.gemReward} Gems</p>
                            </div>
                        </div>
                        </div>

                        <div class="mt-3 pt-3 border-t border-gray-600">
                            <button type="button" class="typography-button font-bold ${btnPad} rounded-xl w-full text-center transition-all duration-200 ${buttonClass} shadow-lg hover:shadow-xl btn-min relative z-10 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-400 active:scale-95 active:ring-2 active:ring-yellow-400" ${buttonDisabled ? 'disabled' : ''} aria-label="${buttonText} - Level ${i + 1}">
                                ${buttonText}
                            </button>
                        </div>
                    `;

                    if (!buttonDisabled) {
                        levelCard.querySelector('button').onclick = () => startGame(i);
                    }

                    levelSelectContainer.appendChild(levelCard);

                    // Apply compact/ultra-compact based on available slot size
                    const containerRect = levelSelectContainer.getBoundingClientRect();
                    const slotHeight = containerRect.height / cfg.rows;
                    const slotWidth = containerRect.width / cfg.cols;
                    if (slotWidth < 320 || slotHeight < 230) {
                        levelCard.classList.add('level-card-compact');
                    }
                    const cardHeight = levelCard.scrollHeight;
                    if (cardHeight > (slotHeight - 12)) {
                        levelCard.classList.add('level-card-ultra');
                    } else {
                        levelCard.classList.remove('level-card-ultra');
                    }
                }

                // Bottom pagination
                if (paginationBar) {
                    paginationBar.innerHTML = `
                        <button id="pager-prev" class="bg-gray-800 hover:bg-gray-700 text-white font-bold px-4 py-2 rounded btn-min typography-button focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-400 active:scale-95" aria-label="Previous page">Prev</button>
                        <span class="text-gray-300">Page ${currentPage + 1} of ${totalPagesLocal}</span>
                        <button id="pager-next" class="bg-gray-800 hover:bg-gray-700 text-white font-bold px-4 py-2 rounded btn-min typography-button focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-400 active:scale-95" aria-label="Next page">Next</button>
                    `;
                    const prevBtn = document.getElementById('pager-prev');
                    const nextBtn = document.getElementById('pager-next');
                    prevBtn.onclick = () => scrollLevels(-1);
                    nextBtn.onclick = () => scrollLevels(1);
                    prevBtn.disabled = currentPage === 0;
                    nextBtn.disabled = currentPage >= totalPagesLocal - 1;
                    prevBtn.classList.toggle('opacity-50', prevBtn.disabled);
                    nextBtn.classList.toggle('opacity-50', nextBtn.disabled);
                }

                updateNavButtons(totalPagesLocal);
            }

            renderPage(0);

            scrollLevels = (direction) => {
                renderPage(currentPage + direction);
            };

            // Keep responsive on resize
            window.addEventListener('resize', () => renderPage(currentPage));
            
            window.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowLeft') {
                    scrollLevels(-1);
                } else if (event.key === 'ArrowRight') {
                    scrollLevels(1);
                }
            });
                        // --- Populate Armory with upgrade comparisons ---
            armoryContainer = document.getElementById('armory-container');
            armoryContainer.innerHTML = ''; // Clear old list
            Object.entries(turretTypes).forEach(([id, stats]) => {
                const currentMaxLevel = playerData.turretMaxLevels[id] || 0;
                const baseStats = getTurretStats(id, 1);
                const currentStats = getTurretStats(id, currentMaxLevel || 1);
                const nextLevelStats = currentMaxLevel > 0 && currentMaxLevel < 4 ? getTurretStats(id, currentMaxLevel + 1) : null;
                
                const turretCard = document.createElement('div');
                turretCard.className = 'bg-gradient-to-r from-gray-700 via-gray-600 to-gray-700 card-pad rounded-xl border border-gray-500 hover:border-blue-400 transition-all duration-300 hover:shadow-lg hover:shadow-blue-500/30 cursor-pointer backdrop-blur-sm relative';
                turretCard.setAttribute('role','group');
                turretCard.setAttribute('tabindex','0');
                
                let upgradePreview = '';
                let upgradeButton = '';
                
                if (currentMaxLevel < 4) {
                    if (playerData.gems >= stats.gemUpgradeCost[currentMaxLevel - 1] || (currentMaxLevel === 0 && playerData.gems >= stats.gemUnlockCost)) {
                        const cost = currentMaxLevel === 0 ? stats.gemUnlockCost : stats.gemUpgradeCost[currentMaxLevel - 1];
                        const action = currentMaxLevel === 0 ? 'Unlock' : `Upgrade to Level ${currentMaxLevel + 1}`;
                        upgradeButton = `
                            <button onclick="${currentMaxLevel === 0 ? `unlockTurret('${id}', ${cost})` : `upgradeMaxTurretLevel('${id}', ${cost})`}" class="w-full mt-4 bg-gradient-to-r from-green-600 via-green-500 to-green-600 hover:from-green-700 hover:via-green-600 hover:to-green-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200 hover:scale-105 shadow-lg hover:shadow-green-500/50 btn-min typography-button relative z-10 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-400 active:scale-95" aria-label="${currentMaxLevel === 0 ? `Unlock ${stats.name}` : `Upgrade ${stats.name}`}">
                                ${action} (${cost} üíé)
                            </button>
                        `;
                    } else {
                        const cost = currentMaxLevel === 0 ? stats.gemUnlockCost : stats.gemUpgradeCost[currentMaxLevel - 1];
                        upgradeButton = `
                            <div class="w-full mt-4 bg-gradient-to-r from-gray-800 to-gray-700 text-gray-400 font-bold py-3 px-4 rounded-lg border border-gray-600 text-center cursor-not-allowed btn-min typography-button">
                                Need ${cost} üíé
                            </div>
                        `;
                    }
                    
                    if (nextLevelStats) {
                        const damageIncrease = nextLevelStats.damage - currentStats.damage;
                        const rangeIncrease = nextLevelStats.range - currentStats.range;
                        const fireRateImprovement = currentStats.fireRate - nextLevelStats.fireRate;

                        upgradePreview = `
                            <div class="mt-3 border-t border-green-600 pt-2">
                                <div class="flex items-center justify-between text-xs">
                                    <div class="flex items-center">
                                        <span class="mr-2">‚öîÔ∏è</span>
                                        <span class="text-red-300 typography-desc font-semibold">+${damageIncrease.toFixed(1)}</span>
                                    </div>
                                    <div class="flex items-center">
                                        <span class="mr-2">üéØ</span>
                                        <span class="text-blue-300 typography-desc font-semibold">+${rangeIncrease.toFixed(0)}</span>
                                    </div>
                                    <div class="flex items-center">
                                        <span class="mr-2">‚ö°</span>
                                        <span class="text-purple-300 typography-desc font-semibold">${fireRateImprovement > 0 ? '+' : ''}${fireRateImprovement.toFixed(1)}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                } else {
                    upgradeButton = `
                        <div class="w-full mt-4 bg-gradient-to-r from-yellow-900 via-yellow-800 to-yellow-900 text-yellow-300 font-bold py-3 px-4 rounded-lg border border-yellow-600 text-center shadow-lg backdrop-blur-sm typography-button">
                            <span class="flex items-center justify-center">
                                <span class="mr-2">‚≠ê</span>MAX LEVEL‚≠ê
                                <span class="ml-2">‚≠ê</span>
                            </span>
                        </div>
                    `;
                }
                
                turretCard.innerHTML = `
                    <div class="flex items-center justify-between section-margin">
                        <div class="flex items-center space-x-3">
                            <div class="icon-md drop-shadow-lg" style="color:${stats.color}">üéØ</div>
                            <div>
                                <h3 class="typography-title font-bold text-white drop-shadow-md">${stats.name}</h3>
                                <p class="text-gray-300 typography-desc truncate max-w-[16rem]">${stats.description}</p>
                            </div>
                        </div>
                        <div class="text-right">
                            <span class="inline-flex items-center px-2 py-1 rounded-lg border border-gray-600 bg-gray-800 text-yellow-300 typography-desc">Lvl ${currentMaxLevel || 0}/4</span>
                        </div>
                    </div>

                    <div class="bg-gradient-to-b from-gray-800 via-gray-700 to-gray-800 card-pad rounded-lg border border-gray-600 section-margin">
                        <ul class="text-gray-300 text-xs leading-snug space-y-1">
                            <li class="flex items-center justify-between">
                                <span class="flex items-center"><span class="mr-1">üí∞</span>Cost</span>
                                <span class="text-green-300 font-semibold">$${currentStats.cost}</span>
                            </li>
                            <li class="flex items-center justify-between">
                                <span class="flex items-center"><span class="mr-1">‚öîÔ∏è</span>Damage</span>
                                <span class="text-red-300 font-semibold">${currentStats.damage}</span>
                            </li>
                            <li class="flex items-center justify-between">
                                <span class="flex items-center"><span class="mr-1">üéØ</span>Range</span>
                                <span class="text-blue-300 font-semibold">${currentStats.range}</span>
                            </li>
                            <li class="flex items-center justify-between">
                                <span class="flex items-center"><span class="mr-1">‚ö°</span>Fire</span>
                                <span class="text-purple-300 font-semibold">${currentStats.fireRate}</span>
                            </li>
                        </ul>
                    </div>

                    ${upgradePreview}
                    ${upgradeButton}
                `;
                
                armoryContainer.appendChild(turretCard);
            });
        }
        
        function unlockTurret(turretId, cost) {
            const current = playerData.turretMaxLevels[turretId] || 0;
            const unlockCost = (turretTypes[turretId] && turretTypes[turretId].gemUnlockCost != null)
                ? turretTypes[turretId].gemUnlockCost
                : cost;
            if (current === 0 && playerData.gems >= unlockCost) {
                playerData.gems -= unlockCost;
                playerData.turretMaxLevels[turretId] = 1; // Unlock at level 1
                updateMenuUI();
                saveProgress();
            }
        }
        
        function upgradeMaxTurretLevel(turretId, cost) {
            const current = playerData.turretMaxLevels[turretId] || 0;
            if (current <= 0 || current >= 4) return; // Must be unlocked and below max
            const upgradeCosts = turretTypes[turretId]?.gemUpgradeCost || [];
            const required = upgradeCosts[current - 1] != null ? upgradeCosts[current - 1] : cost;
            if (playerData.gems >= required) {
                playerData.gems -= required;
                playerData.turretMaxLevels[turretId] = Math.min(current + 1, 4);
                updateMenuUI();
                saveProgress();
            }
        }

        // Expose functions globally because script uses type="module"
        window.unlockTurret = unlockTurret;
        window.upgradeMaxTurretLevel = upgradeMaxTurretLevel;
        
        // === DEBUG MENU FUNCTIONS ===
        
        function toggleDebugMenu() {
            if (debugMenu) {
                debugMenu.classList.toggle('hidden');
            }
        }
        
        function unlockAllTurrets() {
            Object.keys(turretTypes).forEach(id => {
                if ((playerData.turretMaxLevels[id] || 0) === 0) {
                    playerData.turretMaxLevels[id] = 1; // Unlock at level 1
                }
            });
            updateMenuUI();
            if (gameContainer.style.display !== 'none') {
                setupTurretButtons(); // Update turret buttons in-game
            }
            saveProgress();
        }
        
        function maxAllTurretLevels() {
            Object.keys(turretTypes).forEach(id => {
                // Set to max level (4, since gemUpgradeCost has 3 values for levels 2, 3, 4)
                playerData.turretMaxLevels[id] = 4;
            });
            updateMenuUI();
            saveProgress();
        }
        
        // === CORE GAME LOGIC ===

        function startGame(levelIndex) {
            // Add transition effects
            mainMenu.classList.add('menu-fade-enter');
            
            setTimeout(() => {
                // Hide menu, show game
                mainMenu.style.display = 'none';
                gameContainer.style.display = 'block';
                gameContainer.classList.remove('menu-fade-enter');
                gameContainer.classList.add('menu-fade-enter-active');
                
                // Resize canvas *after* it's visible
                resizeCanvas();
                
                loadLevel(levelIndex);
                
                // Start game loop
                gameLoopId = requestAnimationFrame(gameLoop);
            }, 150);
        }

        // Function to resize canvas to fit its container while maintaining aspect ratio
        function resizeCanvas() {
            const container = canvas.parentElement; 
            const rect = container.getBoundingClientRect();
            
            // Set internal canvas resolution (native resolution)
            const nativeWidth = 800;
            const nativeHeight = 600;
            const aspectRatio = nativeWidth / nativeHeight;
            
            // Use full available space, no padding
            let displayWidth = rect.width;
            let displayHeight = rect.height;
            
            // If container is wider than needed for aspect ratio, limit width
            if (displayWidth / displayHeight > aspectRatio) {
                displayWidth = displayHeight * aspectRatio;
            } else {
                // Otherwise, limit height
                displayHeight = displayWidth / aspectRatio;
            }
            
            // Center the canvas in the container
            const offsetX = (rect.width - displayWidth) / 2;
            const offsetY = (rect.height - displayHeight) / 2;
            
            // Set canvas internal resolution
            canvas.width = nativeWidth;
            canvas.height = nativeHeight;
            
            // Set display size maintaining aspect ratio - fill as much as possible
            canvas.style.width = `${displayWidth}px`;
            canvas.style.height = `${displayHeight}px`;
            canvas.style.position = 'absolute';
            canvas.style.left = `${offsetX}px`;
            canvas.style.top = `${offsetY}px`;
            canvas.style.maxWidth = '100%';
            canvas.style.maxHeight = '100%';
            
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
        }

        // Initialize the game
        async function init() {
            // --- Assign all UI elements ---
            loadingOverlay = document.getElementById('loading-overlay');
            startMenu = document.getElementById('start-menu');
            mainMenu = document.getElementById('main-menu');
            gameContainer = document.getElementById('game-container');
            levelSelectContainer = document.getElementById('level-select-container');
            armoryContainer = document.getElementById('armory-container');
            gemDisplay = document.getElementById('gem-display');
            gemDisplayStart = document.getElementById('gem-display-start');
            gemDisplayMenu = document.getElementById('gem-display-menu');
            
            // New menu elements
            navLevels = document.getElementById('nav-levels');
            navArmory = document.getElementById('nav-armory');
            levelSelectView = document.getElementById('level-select-view');
            armoryView = document.getElementById('armory-view');
            levelNavLeft = document.getElementById('level-nav-left');
            levelNavRight = document.getElementById('level-nav-right');
            backToStartBtn = document.getElementById('back-to-start-btn');
            startPlayBtn = document.getElementById('start-play-btn');
            // Settings elements
            const settingsBtn = document.getElementById('settings-btn');
            const settingsModal = document.getElementById('settings-modal');
            const settingsClose = document.getElementById('settings-close');
            const settingsSaveClose = document.getElementById('settings-save-close');
            const settingsSlots = document.getElementById('settings-slots');
            const settingsClearSlot = document.getElementById('settings-clear-slot');
            const settingsAudio = document.getElementById('settings-audio');
            const settingsMusic = document.getElementById('settings-music');

            // --- Load Update Logs ---
            try {
                const response = await fetch('updates.csv');
                const csvText = await response.text();
                updateLogs = csvText.split('\n').slice(1).filter(row => row.trim() !== '').map(row => {
                    const [version, log_entry] = row.split(',');
                    return { version, log_entry };
                });
            } catch (error) {
                console.error('Failed to load update logs:', error);
            }

            // Armory elements removed - armory is now permanently visible in sidebar

            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            moneyDisplay = document.getElementById('money-display');
            livesDisplay = document.getElementById('lives-display');
            levelDisplay = document.getElementById('level-display');
            waveDisplay = document.getElementById('wave-display');
            startWaveBtn = document.getElementById('start-wave-btn');
            speedDownBtn = document.getElementById('speed-down-btn');
            speedUpBtn = document.getElementById('speed-up-btn');
            speedDisplay = document.getElementById('speed-display');
            towerSelectionUI = document.getElementById('tower-selection-ui');
            backToMenuBtn = document.getElementById('back-to-menu-btn');

            messageBox = document.getElementById('message-box');
            messageTitle = document.getElementById('message-title');
            messageText = document.getElementById('message-text');
            messageButton1 = document.getElementById('message-button-1');
            messageButton2 = document.getElementById('message-button-2');

            // Settings modal helpers
            function renderSettingsSlots() {
                settingsSlots.innerHTML = '';
                const active = getActiveSlot();
                for (let i = 1; i <= 4; i++) {
                    const data = loadFromSlot(i);
                    const gems = data?.gems ?? '‚Äî';
                    const completed = Array.isArray(data?.completedLevels) ? data.completedLevels.length : 0;
                    const isActive = i === active;
                    const row = document.createElement('div');
                    row.className = `flex items-center justify-between p-2 rounded-lg border ${isActive ? 'border-purple-500 bg-purple-900 bg-opacity-20' : 'border-gray-700 bg-gray-800 bg-opacity-50'}`;
                    row.innerHTML = `
                        <label class="flex items-center space-x-2">
                            <input type="radio" name="save-slot" value="${i}" ${isActive ? 'checked' : ''} />
                            <span>Slot ${i}</span>
                        </label>
                        <div class="text-sm text-gray-300">Gems: <span class="font-bold">${gems}</span> ‚Ä¢ Levels: ${completed}</div>
                    `;
                    settingsSlots.appendChild(row);
                }
                // Set preferences
                settingsAudio.checked = !!playerData.settings?.audioEnabled;
                settingsMusic.checked = !!playerData.settings?.musicEnabled;
            }

            function renderUpdateLogs() {
                const updateLogList = document.getElementById('update-log-list');
                if (updateLogList) {
                    updateLogList.innerHTML = ''; // Clear existing logs
                    updateLogs.forEach(log => {
                        const listItem = document.createElement('li');
                        listItem.textContent = log.log_entry;
                        updateLogList.appendChild(listItem);
                    });
                }
            }

            function openSettings() {
                renderSettingsSlots();
                renderUpdateLogs(); // Render update logs when settings open
                settingsModal.classList.remove('hidden');
            }
            function closeSettings() {
                settingsModal.classList.add('hidden');
            }

            // Settings events
            if (settingsBtn) settingsBtn.addEventListener('click', openSettings);
            if (settingsClose) settingsClose.addEventListener('click', closeSettings);
            if (settingsSaveClose) settingsSaveClose.addEventListener('click', closeSettings);
            if (settingsClearSlot) settingsClearSlot.addEventListener('click', () => {
                const selected = document.querySelector('input[name="save-slot"]:checked');
                const slot = selected ? parseInt(selected.value, 10) : getActiveSlot();
                clearSaveSlot(slot, turretTypes);
                renderSettingsSlots();
            });
            settingsSlots.addEventListener('change', (e) => {
                if (e.target && e.target.name === 'save-slot') {
                    const slot = parseInt(e.target.value, 10);
                    switchSaveSlot(slot, turretTypes);
                    renderSettingsSlots();
                }
            });
            if (settingsAudio) settingsAudio.addEventListener('change', (e) => {
                playerData.settings = playerData.settings || {};
                playerData.settings.audioEnabled = !!e.target.checked;
                saveProgress();
            });
            if (settingsMusic) settingsMusic.addEventListener('change', (e) => {
                playerData.settings = playerData.settings || {};
                playerData.settings.musicEnabled = !!e.target.checked;
                saveProgress();
            });
            // --- Assign new turret menu elements ---
            turretMenu = document.getElementById('turret-menu');
            turretMenuTitle = document.getElementById('turret-menu-title');
            turretMenuStats = document.getElementById('turret-menu-stats');
            turretMenuUpgrade = document.getElementById('turret-menu-upgrade');
            turretMenuSell = document.getElementById('turret-menu-sell');
            // turretMenuClose removed - no close button needed
            turretMenuUpgradePreview = document.getElementById('turret-menu-upgrade-preview');
            // --- End of element assignment ---

            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('click', onMouseClick);
            startWaveBtn.addEventListener('click', startWave);
            backToMenuBtn.addEventListener('click', showStartMenu);

            // Speed control listeners
            function clampSpeed(val) { return Math.max(1, Math.min(8, val)); }
            function updateSpeedUI() {
                if (speedDisplay) speedDisplay.textContent = `${gameSpeed}x`;
                if (speedDownBtn) speedDownBtn.disabled = gameSpeed <= 1;
                if (speedUpBtn) speedUpBtn.disabled = gameSpeed >= 8;
            }
            if (speedDownBtn) {
                speedDownBtn.addEventListener('click', () => {
                    gameSpeed = clampSpeed(gameSpeed - 1);
                    updateSpeedUI();
                });
            }
            if (speedUpBtn) {
                speedUpBtn.addEventListener('click', () => {
                    gameSpeed = clampSpeed(gameSpeed + 1);
                    updateSpeedUI();
                });
            }
            updateSpeedUI();
            
            // Menu navigation
            startPlayBtn.addEventListener('click', showMainMenu);
            backToStartBtn.addEventListener('click', showStartMenu);
            levelNavLeft.addEventListener('click', () => scrollLevels(-1));
            levelNavRight.addEventListener('click', () => scrollLevels(1));
            
            // Armory toggle removed - armory is now permanently visible

            // --- Turret Menu Listeners ---
            // turretMenuClose removed - menu closes when clicking elsewhere
            turretMenuUpgrade.addEventListener('click', upgradeSelectedTurret);
            turretMenuSell.addEventListener('click', sellSelectedTurret);
            
            // --- Debug Menu Elements ---
            debugMenu = document.getElementById('debug-menu');
            debugClose = document.getElementById('debug-close');
            debugAddGems = document.getElementById('debug-add-gems');
            debugAddMoney = document.getElementById('debug-add-money');
            debugUnlockAll = document.getElementById('debug-unlock-all');
            debugMaxAll = document.getElementById('debug-max-all');
            debugAddLives = document.getElementById('debug-add-lives');
            
            // --- Debug Menu Listeners ---
            debugClose.addEventListener('click', toggleDebugMenu);
            debugAddGems.addEventListener('click', () => { playerData.gems += 100; updateMenuUI(); saveProgress(); });
            debugAddMoney.addEventListener('click', () => { money += 1000; updateInGameUI(); });
            debugUnlockAll.addEventListener('click', unlockAllTurrets);
            debugMaxAll.addEventListener('click', maxAllTurretLevels);
            debugAddLives.addEventListener('click', () => { lives += 10; updateInGameUI(); });
            
            // --- Keyboard shortcut for debug menu (Press 'D') ---
            document.addEventListener('keydown', (e) => {
                if (e.key === 'd' || e.key === 'D') {
                    // Don't trigger if typing in an input field
                    if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                        toggleDebugMenu();
                    }
                }
            });
            
            // Load game data from CSV files
            loadingOverlay.style.display = 'flex';
            try {
                await loadGameData();
            } catch (error) {
                loadingOverlay.innerHTML = `
                    <div class="text-center p-8">
                        <div class="text-2xl font-bold text-red-400 mb-4">Error loading game data</div>
                        <div class="text-lg text-gray-300 mb-4">${error.message}</div>
                        <div class="text-sm text-gray-400">
                            <p class="mb-2">If you're opening the HTML file directly, you need to use a local web server:</p>
                            <p class="mb-1"><strong>Python:</strong> python -m http.server 8000</p>
                            <p class="mb-1"><strong>Node.js:</strong> npx http-server</p>
                            <p class="mb-1"><strong>VS Code:</strong> Use the "Live Server" extension</p>
                            <p class="mt-4">Then open: http://localhost:8000/towerdefence.html</p>
                        </div>
                    </div>
                `;
                return;
            }
            
            // Initialize save system and load active slot (fallback to defaults)
            const activeSlot = getActiveSlot();
            const loaded = loadFromSlot(activeSlot);
            playerData = mergeDataWithDefaults(loaded, turretTypes);
            saveProgress();
            
            updateMenuUI();
            loadingOverlay.style.display = 'none';
            showStartMenu();
        }
        
        function showStartMenu() {
            // Add transition effects
            mainMenu.classList.add('menu-fade-enter');
            gameContainer.classList.add('menu-fade-enter');
            
            setTimeout(() => {
                mainMenu.style.display = 'none';
                gameContainer.style.display = 'none';
                messageBox.style.display = 'none';
                
                startMenu.style.display = 'flex';
                startMenu.classList.remove('menu-fade-enter');
                startMenu.classList.add('menu-fade-enter-active');
                
                closeTurretMenu();
                
                if (gameLoopId) {
                    cancelAnimationFrame(gameLoopId);
                    gameLoopId = null;
                }
                
                if (playerData && gemDisplayStart) {
                    gemDisplayStart.textContent = playerData.gems || 0;
                }
            }, 150);
        }
        

        
        function scrollLevels(direction) {
            const container = levelSelectContainer;
            if (!container) return;
            const cards = Array.from(container.children);
            if (cards.length === 0) return;

            const containerRect = container.getBoundingClientRect();
            const containerCenter = container.scrollLeft + containerRect.width / 2;

            // Find the card whose center is closest to the container center
            let currentIndex = 0;
            let minDist = Infinity;
            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                const cardCenter = card.offsetLeft + card.offsetWidth / 2;
                const dist = Math.abs(cardCenter - containerCenter);
                if (dist < minDist) {
                    minDist = dist;
                    currentIndex = i;
                }

                // Re-render page on resize to re-evaluate compactness
                if (!window.__levelSelectResizeBound) {
                    window.addEventListener('resize', () => renderPage(currentPage));
                    window.__levelSelectResizeBound = true;
                }
            }

            const targetIndex = Math.min(cards.length - 1, Math.max(0, currentIndex + direction));
            const target = cards[targetIndex];
            const paddingLeft = parseFloat(getComputedStyle(container).paddingLeft) || 0;
            const targetLeft = target.offsetLeft - paddingLeft;
            container.scrollTo({ left: targetLeft, behavior: 'smooth' });
        }

        // Load a level's data
        function setLevelTheme(levelIndex) {
            const level = levels[levelIndex];
            if (!level) return;
            
            // Set level-specific theme based on level index or name
            let theme = 'default';
            if (levelIndex === 0 || (level.name && level.name.toLowerCase().includes('forest'))) {
                theme = 'forest';
            } else if (levelIndex === 1 || (level.name && level.name.toLowerCase().includes('desert'))) {
                theme = 'desert';
            } else if (levelIndex === 2 || (level.name && level.name.toLowerCase().includes('snow'))) {
                theme = 'snow';
            } else if (levelIndex === 3 || (level.name && level.name.toLowerCase().includes('volcan'))) {
                theme = 'volcanic';
            }
            
            level.pathStyle = theme;
            
            // Apply theme to game container
            const gameContainer = document.getElementById('game-container');
            gameContainer.className = gameContainer.className.replace(/theme-\w+/g, '');
            gameContainer.classList.add(`theme-${theme}`);
        }
        
        function loadLevel(levelIndex) {
            currentLevel = levelIndex;
            currentWave = 0;
            const levelData = levels[currentLevel];
            
            money = levelData.startingMoney;
            lives = levelData.startingLives;
            currentPath = levelData.path;

            // Reset per-level stats
            enemiesDefeated = 0;
            moneyEarned = 0;
            turretsPlaced = 0;
            elapsedTimeMs = 0;
            
            // Set level theme
            setLevelTheme(levelIndex);
            
            turrets = [];
            enemies = [];
            projectiles = [];
            particles = [];
            spawnQueue = [];
            selectedTurret = null;
            selectedTowerType = null;
            
            gameState = 'waiting';
            updateInGameUI();
            setupTurretButtons(); // Populate turret bar
            closeTurretMenu();
            
            startWaveBtn.disabled = false;
            startWaveBtn.textContent = 'Start Wave';
        }
        
        // Dynamically create tower buttons based on unlocks
        function setupTurretButtons() {
            towerSelectionUI.innerHTML = ''; // Clear old buttons
            
            // Create a container for turret cards similar to level cards
            const turretCardsContainer = document.createElement('div');
            turretCardsContainer.className = 'flex space-x-4 overflow-x-auto pb-2 scrollbar-themed';
            
            getUnlockedTurrets().forEach(turretId => {
                const stats = getTurretStats(turretId, 1); // Get Lvl 1 stats
                if (!stats) return;
                
                const turretCard = document.createElement('div');
                turretCard.className = 'tower-button bg-gray-800 hover:bg-gray-700 rounded-xl p-4 min-w-[120px] flex flex-col items-center justify-between cursor-pointer transition-all duration-200 hover:scale-105 hover:shadow-xl border-2 border-gray-600 hover:border-blue-500';
                turretCard.id = `buy-${turretId}`;
                
                turretCard.innerHTML = `
                    <div class="text-center mb-3">
                        <div class="text-2xl mb-1" style="color:${turretTypes[turretId].color}">üéØ</div>
                        <h3 class="text-sm font-bold text-white">${stats.name}</h3>
                    </div>
                    <div class="text-center text-xs text-gray-300 space-y-1">
                        <p>Cost: <span class="font-bold text-green-300">$${stats.cost}</span></p>
                        <p>DMG: <span class="font-bold text-red-300">${stats.damage}</span></p>
                        <p>RNG: <span class="font-bold text-blue-300">${stats.range}</span></p>
                    </div>
                `;
                
                turretCard.onclick = () => selectTower(turretId);
                turretCardsContainer.appendChild(turretCard);
            });
            
            towerSelectionUI.appendChild(turretCardsContainer);
        }
        
        // Start the next wave
        function startWave() {
            if (gameState !== 'waiting' || !levels[currentLevel] || !levels[currentLevel].waves[currentWave]) return;
            
            closeTurretMenu(); // Close menu when wave starts
            
            gameState = 'playing';
            spawnQueue = [];
            spawnCounter = 0;
            
            const waveData = levels[currentLevel].waves[currentWave].enemies;
            
            waveData.forEach(group => {
                let spawnTime = group.delay || 0;
                for (let i = 0; i < group.count; i++) {
                    spawnQueue.push({ type: group.type, time: spawnTime });
                    spawnTime += group.spawnRate;
                }
            });
            
            spawnQueue.sort((a, b) => a.time - b.time);
            
            startWaveBtn.disabled = true;
            startWaveBtn.textContent = 'Wave in Progress...';
            updateInGameUI();
        }

        // Main Game Loop
        function gameLoop(timestamp) {
            const deltaTime = (timestamp - lastTime) / 16.67; // Normalize to ~60 FPS
            lastTime = timestamp;

            if (isNaN(deltaTime) || deltaTime <= 0) { // Skip first frame or bad timestamp
                gameLoopId = requestAnimationFrame(gameLoop);
                return;
            }

            // Apply gameplay speed (clamped 1x‚Äì8x) and track elapsed time
            const speed = Math.max(1, Math.min(8, gameSpeed));
            const adjustedDelta = deltaTime * speed;
            if (gameState === 'playing' || gameState === 'waiting') {
                elapsedTimeMs += adjustedDelta * 16.67;
            }

            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            drawPath();
            
            if (gameState === 'playing') {
                handleSpawning(adjustedDelta);
                updateEnemies(adjustedDelta);
            }
            
            updateTurrets(adjustedDelta);
            updateProjectiles(adjustedDelta);
            updateParticles(adjustedDelta);

            drawTurrets();
            drawEnemies();
            drawProjectiles();
            drawParticles();
            drawGhostTower();
            
            if (gameState !== 'gameover' && gameState !== 'win') {
                gameLoopId = requestAnimationFrame(gameLoop);
            } else {
                gameLoopId = null; // Stop loop
            }
        }

        // === UPDATE FUNCTIONS ===

        function handleSpawning(deltaTime) {
            if (spawnQueue.length > 0) {
                // Use deltaTime (normalized frames) so gameSpeed affects spawn spacing
                spawnCounter += deltaTime;
                while (spawnQueue.length > 0 && spawnCounter >= spawnQueue[0].time) {
                    const enemyData = spawnQueue.shift();
                    spawnEnemy(enemyData.type);
                }
            } else if (enemies.length === 0) {
                // Check if spawnQueue is also empty, meaning all enemies are spawned and defeated
                endWave();
            }
        }
        
        function spawnEnemy(type) {
            const enemyData = enemyTypes[type];
            enemies.push({
                ...enemyData,
                x: currentPath[0].x,
                y: currentPath[0].y,
                currentHp: enemyData.hp,
                waypointIndex: 1
            });
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                if (enemy.currentHp <= 0) {
                    // Create death particles
                    createDeathParticles(enemy.x, enemy.y, enemy.color, enemy.radius);
                    money += enemy.reward;
                    moneyEarned += enemy.reward;
                    enemiesDefeated++;
                    updateInGameUI();
                    enemies.splice(i, 1);
                    continue;
                }

                const targetWaypoint = currentPath[enemy.waypointIndex];
                if (!targetWaypoint) continue; 

                const dx = targetWaypoint.x - enemy.x;
                const dy = targetWaypoint.y - enemy.y;
                const dist = Math.hypot(dx, dy);
                const moveDist = enemy.speed * deltaTime;

                if (dist < moveDist) {
                    enemy.x = targetWaypoint.x;
                    enemy.y = targetWaypoint.y;
                    enemy.waypointIndex++;
                    
                    if (enemy.waypointIndex >= currentPath.length) {
                        lives -= enemy.damage;
                        enemies.splice(i, 1);
                        updateInGameUI();
                        checkGameOver();
                    }
                } else {
                    enemy.x += (dx / dist) * moveDist;
                    enemy.y += (dy / dist) * moveDist;
                }
            }
        }
        
        function updateTurrets(deltaTime) {
            turrets.forEach(turret => {
                // Get the turret's stats for its CURRENT level
                const stats = getTurretStats(turret.type, turret.level);
                if (!stats) return; 
                
                const target = findTarget(turret, stats.range);
                
                if (target) {
                    turret.angle = Math.atan2(target.y - turret.y, target.x - turret.x);
                    
                    if (turret.cooldown <= 0) {
                        fireProjectile(turret, target, stats); // Pass stats in
                        turret.cooldown = stats.fireRate;
                    }
                }
                
                turret.cooldown -= 1 * deltaTime;
            });
        }
        
        function findTarget(turret, range) {
            let bestTarget = null;
            let maxDist = 0;

            for (const enemy of enemies) {
                const dist = Math.hypot(enemy.x - turret.x, enemy.y - turret.y);
                
                if (dist <= range) {
                    const enemyPathDist = getEnemyPathDistance(enemy);
                    if (enemyPathDist > maxDist) {
                        maxDist = enemyPathDist;
                        bestTarget = enemy;
                    }
                }
            }
            return bestTarget;
        }

        function getEnemyPathDistance(enemy) {
            let dist = 0;
            for (let i = 1; i < enemy.waypointIndex; i++) {
                dist += Math.hypot(currentPath[i].x - currentPath[i-1].x, currentPath[i].y - currentPath[i-1].y);
            }
            dist += Math.hypot(enemy.x - currentPath[enemy.waypointIndex-1].x, enemy.y - currentPath[enemy.waypointIndex-1].y);
            return dist;
        }
        
        function fireProjectile(turret, target, stats) {
            const gunTipX = turret.x + 18 * Math.cos(turret.angle);
            const gunTipY = turret.y + 18 * Math.sin(turret.angle);

            projectiles.push({
                x: gunTipX, y: gunTipY,
                damage: stats.damage, // Use calculated damage
                speed: stats.projectileSpeed, 
                color: stats.projectileColor,
                target: target, targetLost: false,
                lastTargetX: target.x, lastTargetY: target.y
            });
        }

        function updateProjectiles(deltaTime) {
             for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                
                if (!p.target || p.target.currentHp <= 0 || !enemies.includes(p.target)) {
                    p.targetLost = true;
                }
                
                let targetX = p.targetLost ? p.lastTargetX : p.target.x; 
                let targetY = p.targetLost ? p.lastTargetY : p.target.y;
                
                if (!p.targetLost) {
                    p.lastTargetX = targetX;
                    p.lastTargetY = targetY;
                }

                const dx = targetX - p.x;
                const dy = targetY - p.y;
                const dist = Math.hypot(dx, dy);
                const moveDist = p.speed * deltaTime;

                if (dist < moveDist) {
                    if (!p.targetLost && p.target) {
                         p.target.currentHp -= p.damage;
                    }
                    projectiles.splice(i, 1);
                } else {
                    p.x += (dx / dist) * moveDist;
                    p.y += (dy / dist) * moveDist;
                }
            }
        }
        
        // === DRAW FUNCTIONS ===
        
        function drawPath() {
            if (!currentPath || currentPath.length === 0) return;
            
            // Get level-specific path styling
            const levelData = levels[currentLevel];
            const pathStyle = levelData.pathStyle || 'default';
            const pathColors = {
                forest: { primary: '#8B4513', secondary: '#A0522D', border: '#654321' },
                desert: { primary: '#D2691E', secondary: '#DEB887', border: '#CD853F' },
                snow: { primary: '#B0C4DE', secondary: '#E6E6FA', border: '#708090' },
                volcanic: { primary: '#8B0000', secondary: '#DC143C', border: '#4B0000' },
                default: { primary: '#9ca3af', secondary: '#6b7280', border: '#1f2937' }
            };
            
            const colors = pathColors[pathStyle] || pathColors.default;
            
            // Draw path border (shadow effect)
            ctx.strokeStyle = colors.border;
            ctx.lineWidth = pathWidth + 4; 
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) ctx.lineTo(currentPath[i].x, currentPath[i].y);
            ctx.stroke();
            
            // Draw main path with texture pattern
            ctx.strokeStyle = colors.primary;
            ctx.lineWidth = pathWidth;
            
            // Add texture pattern for different path types
            if (pathStyle === 'forest') {
                // Forest path - darker, earthier tones
                ctx.setLineDash([5, 3]);
            } else if (pathStyle === 'desert') {
                // Desert path - sandy texture
                ctx.setLineDash([2, 2]);
            } else if (pathStyle === 'snow') {
                // Snow path - icy appearance
                ctx.setLineDash([8, 4]);
            } else if (pathStyle === 'volcanic') {
                // Volcanic path - lava cracks
                ctx.setLineDash([1, 1]);
            }
            
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) ctx.lineTo(currentPath[i].x, currentPath[i].y);
            ctx.stroke();
            
            // Reset line dash
            ctx.setLineDash([]);
            
            // Add secondary path highlight
            ctx.strokeStyle = colors.secondary;
            ctx.lineWidth = pathWidth * 0.3;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.moveTo(currentPath[0].x, currentPath[0].y);
            for (let i = 1; i < currentPath.length; i++) ctx.lineTo(currentPath[i].x, currentPath[i].y);
            ctx.stroke();
            ctx.globalAlpha = 1.0;
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                // Draw enemy with gradient and shadow for depth
                const gradient = ctx.createRadialGradient(enemy.x, enemy.y, 0, enemy.x, enemy.y, enemy.radius);
                gradient.addColorStop(0, enemy.color);
                gradient.addColorStop(1, darkenColor(enemy.color, 0.3));
                
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(enemy.x + 2, enemy.y + enemy.radius + 2, enemy.radius * 0.8, enemy.radius * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Main body
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Highlight
                ctx.fillStyle = lightenColor(enemy.color, 0.3);
                ctx.beginPath();
                ctx.arc(enemy.x - enemy.radius * 0.3, enemy.y - enemy.radius * 0.3, enemy.radius * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // HP Bar
                const hpBarWidth = enemy.radius * 2;
                const hpBarHeight = 5;
                const hpBarX = enemy.x - enemy.radius;
                const hpBarY = enemy.y - enemy.radius - 8;
                ctx.fillStyle = '#1f2937';
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                const hpPercent = enemy.currentHp / enemy.hp;
                ctx.fillStyle = hpPercent > 0.5 ? '#22c55e' : (hpPercent > 0.2 ? '#f59e0b' : '#ef4444');
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpPercent, hpBarHeight);
            });
        }
        
        function createDeathParticles(x, y, color, radius) {
            const particleCount = Math.max(8, Math.floor(radius * 2));
            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount;
                const speed = 2 + Math.random() * 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.02,
                    size: 3 + Math.random() * 3,
                    color: color
                });
            }
        }
        
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.life -= p.decay * deltaTime;
                p.vy += 0.2 * deltaTime; // Gravity
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }
        
        function darkenColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.max(0, parseInt(hex.substr(0, 2), 16) * (1 - amount));
            const g = Math.max(0, parseInt(hex.substr(2, 2), 16) * (1 - amount));
            const b = Math.max(0, parseInt(hex.substr(4, 2), 16) * (1 - amount));
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }
        
        function lightenColor(color, amount) {
            const hex = color.replace('#', '');
            const r = Math.min(255, parseInt(hex.substr(0, 2), 16) + (255 * amount));
            const g = Math.min(255, parseInt(hex.substr(2, 2), 16) + (255 * amount));
            const b = Math.min(255, parseInt(hex.substr(4, 2), 16) + (255 * amount));
            return `rgb(${Math.floor(r)}, ${Math.floor(g)}, ${Math.floor(b)})`;
        }

        function drawTurrets() {
            turrets.forEach(turret => {
                const stats = getTurretStats(turret.type, turret.level);
                const x = turret.x; const y = turret.y;
                
                // Draw range circle (only when selected or placing)
                if (turret === selectedTurret) {
                    ctx.fillStyle = 'rgba(59, 130, 246, 0.1)';
                    ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)';
                    ctx.lineWidth = 2; 
                    ctx.beginPath();
                    ctx.arc(x, y, stats.range, 0, Math.PI * 2);
                    ctx.fill(); ctx.stroke();
                }

                // Draw selection circle if this turret is selected
                if (turret === selectedTurret) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, 16, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Pulsing effect
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 18, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw turret base with gradient
                const baseGradient = ctx.createRadialGradient(x, y, 0, x, y, 12);
                baseGradient.addColorStop(0, lightenColor(stats.color, 0.2));
                baseGradient.addColorStop(1, stats.color);
                ctx.fillStyle = baseGradient;
                ctx.beginPath();
                ctx.arc(x, y, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // Base border
                ctx.strokeStyle = darkenColor(stats.color, 0.3);
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw turret gun with better detail
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(turret.angle);
                
                // Gun shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(2, 1, 18, 6);
                
                // Gun body
                const gunGradient = ctx.createLinearGradient(0, -3, 0, 3);
                gunGradient.addColorStop(0, '#cbd5e1');
                gunGradient.addColorStop(1, '#64748b');
                ctx.fillStyle = gunGradient;
                ctx.fillRect(0, -3, 18, 6);
                
                // Gun tip
                ctx.fillStyle = '#475569';
                ctx.fillRect(16, -2, 4, 4);
                
                ctx.restore();

                // Draw level pips with glow
                const pipCount = turret.level;
                const pipRadius = 3;
                const pipSpacing = 6;
                const totalPipWidth = (pipCount - 1) * pipSpacing;
                const startX = x - totalPipWidth / 2;
                const yOffset = 18;
                for (let i = 0; i < pipCount; i++) {
                    const pipX = startX + i * pipSpacing;
                    // Glow
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = '#f59e0b';
                    ctx.fillStyle = '#f59e0b';
                    ctx.beginPath();
                    ctx.arc(pipX, y + yOffset, pipRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        function drawProjectiles() {
            projectiles.forEach(p => {
                // Glow effect
                ctx.shadowBlur = 8;
                ctx.shadowColor = p.color;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Core
                ctx.shadowBlur = 0;
                ctx.fillStyle = lightenColor(p.color, 0.5);
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawGhostTower() {
            if (!selectedTowerType) return;
            const stats = getTurretStats(selectedTowerType, 1); // Ghost is always Lvl 1
            const validPlacement = isPlacementValid(mouse.x, mouse.y, stats.cost);
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = validPlacement ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 0, 0, 0.2)';
            ctx.beginPath(); ctx.arc(mouse.x, mouse.y, stats.range, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = stats.color;
            ctx.beginPath(); ctx.arc(mouse.x, mouse.y, 12, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        // === EVENT HANDLERS ===
        
        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        }

        function onMouseClick(e) {
            // Priority 1: Placing a new tower
            if (selectedTowerType) {
                const stats = getTurretStats(selectedTowerType, 1);
                if (isPlacementValid(mouse.x, mouse.y, stats.cost)) {
                    money -= stats.cost;
                    turrets.push({ x: mouse.x, y: mouse.y, type: selectedTowerType, level: 1, cooldown: 0, angle: 0 });
                    turretsPlaced++;
                    updateInGameUI();
                    selectTower(null); // Deselect build mode
                } else {
                    console.log('Invalid placement');
                    selectTower(null); // Deselect build mode
                }
                return; // Action taken
            }
            
            // Priority 2: Check if we clicked on an existing turret
            const clickedTurret = turrets.find(t => Math.hypot(mouse.x - t.x, mouse.y - t.y) < 12);
            if (clickedTurret) {
                if (selectedTurret === clickedTurret) {
                    // Clicked same turret, close menu
                    closeTurretMenu();
                } else {
                    // Clicked a different turret
                    selectedTurret = clickedTurret;
                    openTurretMenu(clickedTurret);
                }
                return; // Action taken
            }

            // Priority 3: Clicked on empty space
            // If we're not building and didn't click a turret, close any open menus
            selectTower(null); // Close build mode
            closeTurretMenu(); // Close upgrade menu
        }
        
        function selectTower(type) {
            if (type) {
                closeTurretMenu(); // Can't have both open
            }
            selectedTowerType = type;
            // Update button styles
            document.querySelectorAll('.tower-button').forEach(btn => {
                if (type && btn.id === `buy-${type}`) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }

        // === NEW TURRET MENU FUNCTIONS ===
        
        function openTurretMenu(turret) {
            selectedTurret = turret;
            const stats = getTurretStats(turret.type, turret.level);
            
            // 1. Set Title and Stats
            turretMenuTitle.textContent = `${stats.name} (Level ${turret.level})`;
            turretMenuStats.innerHTML = `
                <p>Damage: <span class="font-bold text-white">${stats.damage}</span></p>
                <p>Range: <span class="font-bold text-white">${stats.range}</span></p>
                <p>Rate: <span class="font-bold text-white">${stats.fireRate}</span></p>
            `;
            
            // 2. Show Upgrade Preview if upgrade available
            const maxLevel = playerData.turretMaxLevels[turret.type];
            if (turret.level < maxLevel && stats.nextUpgradeCost) {
                const nextStats = getTurretStats(turret.type, turret.level + 1);
                const dmgDiff = nextStats.damage - stats.damage;
                const rangeDiff = nextStats.range - stats.range;
                const rateDiff = nextStats.fireRate - stats.fireRate;
                
                turretMenuUpgradePreview.innerHTML = `
                    <p class="text-purple-300 font-semibold mb-1">Next Level:</p>
                    ${dmgDiff > 0 ? `<p>DMG: <span class="text-green-400">${stats.damage} ‚Üí ${nextStats.damage} (+${dmgDiff})</span></p>` : ''}
                    ${rangeDiff > 0 ? `<p>Range: <span class="text-blue-400">${stats.range} ‚Üí ${nextStats.range} (+${rangeDiff})</span></p>` : ''}
                    ${rateDiff !== 0 ? `<p>Rate: <span class="${rateDiff < 0 ? 'text-yellow-400' : 'text-red-400'}">${stats.fireRate} ‚Üí ${nextStats.fireRate} (${rateDiff < 0 ? 'faster' : 'slower'})</span></p>` : ''}
                `;
                turretMenuUpgradePreview.style.display = 'block';
            } else {
                turretMenuUpgradePreview.style.display = 'none';
            }
            
            // 3. Configure Upgrade Button
            if (turret.level >= maxLevel) {
                turretMenuUpgrade.textContent = 'Max Level';
                turretMenuUpgrade.disabled = true;
                turretMenuUpgrade.className = 'flex-1 game-button bg-gray-600 cursor-not-allowed';
            } else {
                const upgradeCost = stats.nextUpgradeCost;
                turretMenuUpgrade.textContent = `Upgrade ($${upgradeCost})`;
                if (money >= upgradeCost) {
                    turretMenuUpgrade.disabled = false;
                    turretMenuUpgrade.className = 'flex-1 game-button bg-green-600 hover:bg-green-700';
                } else {
                    turretMenuUpgrade.disabled = true;
                    turretMenuUpgrade.className = 'flex-1 game-button bg-red-700 cursor-not-allowed';
                }
            }

            // 4. Configure Sell Button
            turretMenuSell.textContent = `Sell ($${stats.sellValue})`;
            
            // 4. Position and Show Menu
            // Convert canvas coords to screen coords
            const rect = canvas.getBoundingClientRect();
            const scaleX = rect.width / canvas.width;
            const scaleY = rect.height / canvas.height;

            // Position relative to the canvas's container
            let menuLeft = (turret.x * scaleX);
            let menuTop = (turret.y * scaleY);

            // Offset menu to not cover turret
            // And prevent going off-screen
            const menuWidth = 256; // w-64
            const menuHeight = 160; // Approx
            
            if (menuLeft + menuWidth + 20 > rect.width) {
                menuLeft -= (menuWidth + 30); // Show on left
            } else {
                menuLeft += 30; // Show on right
            }
            
            if (menuTop + menuHeight > rect.height) {
                menuTop = rect.height - menuHeight - 10;
            }

            turretMenu.style.left = `${Math.max(0, menuLeft)}px`;
            turretMenu.style.top = `${Math.max(0, menuTop)}px`;
            turretMenu.style.display = 'block';
        }

        function closeTurretMenu() {
            if (selectedTurret) {
                selectedTurret = null;
            }
            if (turretMenu) { // Check if it exists yet
                turretMenu.style.display = 'none';
            }
        }

        function upgradeSelectedTurret() {
            if (!selectedTurret) return;
            
            const stats = getTurretStats(selectedTurret.type, selectedTurret.level);
            const upgradeCost = stats.nextUpgradeCost;
            const maxLevel = playerData.turretMaxLevels[selectedTurret.type];

            if (money >= upgradeCost && selectedTurret.level < maxLevel) {
                money -= upgradeCost;
                selectedTurret.level++;
                updateInGameUI();
                openTurretMenu(selectedTurret); // Refresh menu
            }
        }

        function sellSelectedTurret() {
            if (!selectedTurret) return;
            
            const stats = getTurretStats(selectedTurret.type, selectedTurret.level);
            money += stats.sellValue;
            
            // Remove turret from array
            turrets = turrets.filter(t => t !== selectedTurret);
            
            updateInGameUI();
            closeTurretMenu();
        }

        // === UTILITY & GAME STATE ===

        function isPlacementValid(x, y, cost) {
            if (money < cost) return false;
            for (const t of turrets) {
                if (Math.hypot(x - t.x, y - t.y) < 24) return false;
            }
            if (!currentPath) return false;
            for (let i = 0; i < currentPath.length - 1; i++) {
                if (isPointNearLineSegment(x, y, currentPath[i].x, currentPath[i].y, currentPath[i+1].x, currentPath[i+1].y, pathWidth / 2 + 12)) {
                    return false;
                }
            }
            return true;
        }

        function isPointNearLineSegment(px, py, x1, y1, x2, y2, maxDist) {
            const L2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
            if (L2 === 0) return Math.hypot(px - x1, py - y1) < maxDist;
            const t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / L2;
            const tClamped = Math.max(0, Math.min(1, t));
            const nearX = x1 + tClamped * (x2 - x1);
            const nearY = y1 + tClamped * (y2 - y1);
            return Math.hypot(px - nearX, py - nearY) < maxDist;
        }

        function updateInGameUI() {
            moneyDisplay.textContent = money;
            livesDisplay.textContent = lives;
            levelDisplay.textContent = currentLevel + 1;
            waveDisplay.textContent = currentWave + (gameState === 'playing' ? 1 : 0);
            // Keep speed indicator fresh during UI updates
            if (typeof gameSpeed !== 'undefined' && speedDisplay) {
                speedDisplay.textContent = `${gameSpeed}x`;
            }
        }
        
        function endWave() {
            if (gameState !== 'playing') return;
            
            gameState = 'waiting';
            currentWave++;
            startWaveBtn.disabled = false;
            
            if (currentWave >= levels[currentLevel].waves.length) {
                showLevelComplete();
            } else {
                startWaveBtn.textContent = 'Start Wave';
                updateInGameUI();
            }
        }

        function checkGameOver() {
            if (lives <= 0) {
                lives = 0;
                updateInGameUI();
                gameState = 'gameover';
                closeTurretMenu();
                messageTitle.textContent = 'Game Over!';
                messageText.textContent = `You ran out of base HP on level ${currentLevel + 1}, wave ${currentWave + 1}.`;
                
                messageButton1.textContent = 'Restart Level';
                messageButton1.onclick = () => {
                    messageBox.style.display = 'none';
                    loadLevel(currentLevel); // Restart current level
                    gameLoopId = requestAnimationFrame(gameLoop); // Restart loop
                };
                
                messageButton2.textContent = 'Main Menu';
                messageButton2.onclick = () => {
                    showMainMenu();
                };
                messageBox.style.display = 'block';
            }
        }
        
        function showLevelComplete() {
            gameState = 'win';
            closeTurretMenu();
            const reward = levels[currentLevel].gemReward || 0;
            playerData.gems += reward;
            // Mark level as completed and unlock the next one in menu
            if (!playerData.completedLevels.includes(currentLevel)) {
                playerData.completedLevels.push(currentLevel);
            }
            // Update menu UI and persist progress
            updateMenuUI();
            saveProgress();

            messageTitle.textContent = 'Level Complete!';
            messageText.textContent = `You beat level ${currentLevel + 1}! You earned ${reward} gems.`;

            // Populate stats in the overlay
            const setText = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            };
            const totalWaves = levels[currentLevel]?.waves?.length || currentWave;
            const timeSec = Math.round(elapsedTimeMs / 1000);
            setText('stat-waves', `${totalWaves}`);
            setText('stat-enemies', `${enemiesDefeated}`);
            setText('stat-money', `$${moneyEarned}`);
            setText('stat-lives', `${lives}`);
            setText('stat-turrets', `${turretsPlaced}`);
            setText('stat-time', `${timeSec}s`);
            
            messageButton1.textContent = 'Next Level';
            const nextLevel = currentLevel + 1;
            
            if (levels[nextLevel]) {
                messageButton1.disabled = false;
                messageButton1.onclick = () => {
                    messageBox.style.display = 'none';
                    startGame(nextLevel); // Start next level
                };
            } else {
                messageButton1.textContent = 'All Levels Beat!';
                messageButton1.disabled = true;
            }
            
            messageButton2.textContent = 'Main Menu';
            messageButton2.onclick = () => {
                showMainMenu();
            };
            messageBox.style.display = 'block';
        }

        // --- This line starts the entire application ---
        window.addEventListener('DOMContentLoaded', init);

    </script>
</head>
<body class="bg-gray-900 text-gray-200 h-screen flex items-center justify-center">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 text-white flex items-center justify-center z-50">
        <div class="text-2xl font-bold">Loading Game...</div>
    </div>

    <!-- Enhanced Start Menu -->
    <div id="start-menu" class="fixed inset-0 bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 flex flex-col items-center justify-center z-40 menu-transition">
        <!-- Settings button (top-right) -->
        <button id="settings-btn" class="absolute top-4 right-4 bg-gray-800 hover:bg-gray-700 text-white rounded-full p-3 shadow-lg border border-gray-700 focus:outline-none focus:ring-2 focus:ring-purple-500" aria-label="Settings" title="Settings">
            ‚öôÔ∏è
        </button>
        <div class="text-center mb-8 animate-pulse">
            <h1 class="text-4xl md:text-6xl font-bold text-white mb-4 drop-shadow-2xl" style="text-shadow: 0 0 20px rgba(147, 51, 234, 0.8);">TOWER DEFENSE</h1>
            <div class="text-lg md:text-xl text-gray-300 mb-8">Defend your base from waves of enemies</div>
            <div class="text-lg font-semibold bg-purple-900 bg-opacity-50 px-6 py-3 rounded-lg inline-block mb-8">
                Gems: <span id="gem-display-start" class="text-purple-300 font-bold">0</span>
            </div>
        </div>
        <button id="start-play-btn" class="game-button bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white font-bold text-xl md:text-2xl py-3 md:py-4 px-8 md:px-12 rounded-xl shadow-2xl transform transition-all duration-200 hover:scale-105 active:scale-95">
            PLAY
        </button>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50">
        <div class="w-full h-full flex items-center justify-center">
            <div class="bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 border border-gray-700 rounded-2xl shadow-2xl w-[95vw] max-w-[950px] p-4 sm:p-6 flex flex-col max-h-[90vh]">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-2xl font-bold text-white">Settings</h2>
                    <button id="settings-close" class="text-gray-300 hover:text-white text-xl">&times;</button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 flex-1 overflow-y-auto scrollbar-themed">
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-4 border border-gray-700">
                        <h3 class="text-lg font-bold text-white mb-2">Save Slots</h3>
                        <div id="settings-slots" class="space-y-2"></div>
                        <div class="mt-3 flex space-x-2">
                            <button id="settings-clear-slot" class="game-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-3 rounded-lg">Clear Selected Slot</button>
                        </div>
                    </div>
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-4 border border-gray-700">
                        <h3 class="text-lg font-bold text-white mb-2">Preferences</h3>
                        <label class="flex items-center space-x-2 mb-2">
                            <input type="checkbox" id="settings-audio" class="form-checkbox">
                            <span>Enable Sound Effects</span>
                        </label>
                        <label class="flex items-center space-x-2">
                            <input type="checkbox" id="settings-music" class="form-checkbox">
                            <span>Enable Music</span>
                        </label>
                    </div>
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-4 border border-gray-700">
                        <h3 class="text-xl font-semibold text-purple-300 mb-3">Updates & Version</h3>
                        <div class="bg-gray-700 p-3 rounded-lg text-sm">
                            <p class="text-white font-bold mb-2">Version: V1.0.0</p>
                            <ul id="update-log-list" class="list-disc list-inside text-gray-300 space-y-1">
                                <!-- Update logs will be loaded here from updates.csv -->
                            </ul>
                        </div>
                    </div>
                    <div class="md:col-span-2 bg-gray-800 bg-opacity-70 rounded-xl p-4 border border-gray-700">
                        <h3 class="text-lg font-bold text-white mb-2">Credits</h3>
                        <p class="text-gray-300 text-sm">Design & Code: You</p>
                        <p class="text-gray-300 text-sm">Art & UI: Tailwind-inspired components</p>
                        <p class="text-gray-300 text-sm">Special Thanks: Playtesters</p>
                    </div>
                </div>
                <div class="flex justify-end space-x-3 mt-4">
                    <button id="settings-save-close" class="game-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Armory Section (removed - now permanently in main menu sidebar) -->

    <!-- Main Menu (Level Select & Armory) -->
    <div id="main-menu" class="hidden fixed inset-0 bg-gray-900 z-30 menu-transition">
        <!-- Compact overlay: Back button (top-left), Gems & Level (top-right) -->
        <button id="back-to-start-btn" class="absolute top-4 left-4 z-30 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg flex items-center space-x-2">
            <span>‚Üê</span>
            <span>Back</span>
        </button>
        <div id="menu-info-overlay" class="absolute top-4 right-4 z-30 flex items-center space-x-4">
            <div class="flex items-center space-x-2 bg-purple-900 bg-opacity-60 px-3 py-2 rounded-lg border border-purple-600">
                <span class="text-purple-300">üíé</span>
                <span id="gem-display-menu" class="text-purple-300 font-bold">0</span>
            </div>
            <div class="flex items-center space-x-2 bg-blue-900 bg-opacity-60 px-3 py-2 rounded-lg border border-blue-600">
                <span id="menu-level-display" class="text-blue-300 font-bold">Level 1</span>
            </div>
        </div>
        
        <!-- Main content area with armory on left (~22% width) and level select on right (~78% width) -->
        <div class="flex h-full">
            <!-- Permanent Armory Sidebar (~22% width) -->
            <div class="w-[22%] bg-gray-800 border-r border-gray-700 flex flex-col">
                <div class="p-6 border-b border-gray-700 bg-gradient-to-b from-gray-800 to-gray-700">
                    <h2 class="text-2xl font-bold text-white mb-2">Armory</h2>
                    <p class="text-gray-400 text-sm">Upgrade Your Arsenal</p>
                </div>
                <div id="armory-container" class="flex-1 min-h-0 p-4 overflow-y-auto space-y-3 scrollbar-themed">
                    <!-- Turret cards will be injected here as vertical list -->
                </div>
            </div>
            
            <!-- Level Select Area (80% width) -->
            <div class="relative bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900">
                <!-- Level Select Header -->
                <div class="bg-gray-800 p-6 border-b border-gray-700 bg-gradient-to-r from-gray-800 to-gray-700">
                    <h2 class="text-3xl font-bold text-white mb-2">Choose Your Battlefield</h2>
                    <p class="text-gray-400">Select a level to defend</p>
                </div>
                
                <!-- Level Select Content Wrapper -->
                <div class="flex items-start px-[3vw]">
                    <div id="level-select-container" class="grid grid-cols-3 grid-rows-2 gap-6 place-items-stretch items-stretch w-full h-full border-4 border-purple-500 relative">
                        <!-- Level cards will be injected here -->
                    </div>
                </div>
                <!-- Bottom pager bar -->
                <div id="level-pagination" class="mt-3 w-full flex items-center justify-center gap-4"></div>
                <button id="level-nav-left" aria-label="Previous page" class="absolute left-0 top-1/2 -translate-y-1/2 z-50 bg-gray-800 hover:bg-gray-700 text-white font-bold rounded-full flex items-center justify-center shadow-2xl transition-all duration-200 hover:scale-110 hover:shadow-purple-500/50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-400 active:scale-95" style="width:clamp(48px,6vw,84px);height:clamp(48px,6vw,84px);font-size:clamp(24px,4vw,48px);">‚Äπ</button>
                <button id="level-nav-right" aria-label="Next page" class="absolute top-1/2 -translate-y-1/2 z-50 bg-gray-800 hover:bg-gray-700 text-white font-bold rounded-full flex items-center justify-center shadow-2xl transition-all duration-200 hover:scale-110 hover:shadow-purple-500/50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-400 active:scale-95" style="width:clamp(48px,6vw,84px);height:clamp(48px,6vw,84px);font-size:clamp(24px,4vw,48px); right: 5vw;">‚Ä∫</button>
            </div>
        </div>
    </div>

    <!-- Enhanced Game Container -->
    <div id="game-container" class="hidden fixed inset-0 bg-gray-900 flex flex-col menu-transition w-full h-full">
        <!-- Optimized Top Game UI Bar -->
        <div class="bg-gray-800 p-2 md:p-3 flex justify-between items-center flex-shrink-0 shadow-lg">
            <div class="flex space-x-3 md:space-x-6 text-sm md:text-base">
                <div class="flex items-center space-x-1">
                    <span class="text-gray-400">üí∞</span>
                    <span>Money: <span id="money-display" class="font-bold text-green-400">0</span></span>
                </div>
                <div class="flex items-center space-x-1">
                    <span class="text-gray-400">‚ù§Ô∏è</span>
                    <span>Base HP: <span id="lives-display" class="font-bold text-red-400">0</span></span>
                </div>
            </div>
            <div class="flex space-x-3 md:space-x-6 text-center text-sm md:text-base">
                <div class="flex items-center space-x-1">
                    <span class="text-gray-400">üéØ</span>
                    <span>Level: <span id="level-display" class="font-bold text-blue-300">1</span></span>
                </div>
                <div class="flex items-center space-x-1">
                    <span class="text-gray-400">üåä</span>
                    <span>Wave: <span id="wave-display" class="font-bold text-yellow-300">0</span></span>
                </div>
            </div>
            <div class="flex space-x-2">
                <button id="start-wave-btn" class="game-button bg-green-600 hover:bg-green-700 text-white font-bold py-1 px-3 text-sm rounded-lg transition-all duration-200 hover:scale-105">Start Wave</button>
                <!-- Gameplay Speed Controls -->
                <div class="flex items-center space-x-2">
                    <button id="speed-down-btn" aria-label="Decrease speed" class="game-button bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 text-sm rounded-lg transition-all duration-200">‚àí</button>
                    <span class="text-gray-300 text-sm">Speed: <span id="speed-display" class="font-bold text-yellow-300">1x</span></span>
                    <button id="speed-up-btn" aria-label="Increase speed" class="game-button bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 text-sm rounded-lg transition-all duration-200">Ôºã</button>
                </div>
                <button id="back-to-menu-btn" class="game-button bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 text-sm rounded-lg transition-all duration-200 hover:scale-105">Menu</button>
            </div>
        </div>

        <!-- Larger Game Area -->
        <div class="flex-1 relative bg-gray-700 w-full h-full">
            <canvas id="game-canvas" class="shadow-2xl w-full h-full"></canvas>

            <!-- Enhanced Turret Upgrade Menu (permanent, no close button) -->
            <div id="turret-menu" class="hidden absolute bg-gray-800 rounded-lg shadow-xl p-4 w-72 text-gray-300 border-2 border-blue-500 z-20 menu-transition">
                <h3 id="turret-menu-title" class="text-xl font-bold mb-2 text-white">Turret</h3>
                <div id="turret-menu-stats" class="text-sm space-y-1 mb-3">
                    <!-- Stats injected here -->
                </div>
                <div id="turret-menu-upgrade-preview" class="text-xs text-gray-400 mb-3 border-t border-gray-700 pt-2">
                    <!-- Upgrade preview injected here -->
                </div>
                <div class="flex space-x-2">
                    <button id="turret-menu-upgrade" class="flex-1 game-button bg-green-600 hover:bg-green-700 transition-all duration-200">Upgrade</button>
                    <button id="turret-menu-sell" class="flex-1 game-button bg-red-600 hover:bg-red-700 transition-all duration-200">Sell</button>
                </div>
            </div>
        </div>

        <!-- Permanent Tower Selection Bar (no close button, always visible) -->
        <div id="tower-selection-ui" class="bg-gray-800 p-2 md:p-3 flex space-x-2 justify-start overflow-x-auto flex-shrink-0 shadow-lg border-t-2 border-gray-600">
            <!-- Tower buttons will be injected here -->
        </div>
    </div>

    <!-- Message Box (Game Over / Win) -->
    <div id="message-box" class="hidden fixed inset-0 bg-black bg-opacity-70 z-40">
        <div class="w-full h-full flex items-center justify-center">
            <div class="bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 border border-gray-700 rounded-2xl shadow-2xl w-[92vw] h-[88vh] p-8 flex flex-col">
                <div class="flex items-center justify-between mb-6">
                    <h2 id="message-title" class="text-4xl font-extrabold text-white">Level Complete!</h2>
                    <div class="text-right">
                        <p id="message-text" class="text-lg text-gray-300">You beat the level.</p>
                    </div>
                </div>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-6 flex-1">
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-6 border border-gray-700">
                        <p class="text-gray-400">Waves Cleared</p>
                        <p id="stat-waves" class="text-3xl font-bold text-yellow-300">0</p>
                    </div>
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-6 border border-gray-700">
                        <p class="text-gray-400">Enemies Defeated</p>
                        <p id="stat-enemies" class="text-3xl font-bold text-red-300">0</p>
                    </div>
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-6 border border-gray-700">
                        <p class="text-gray-400">Gems Earned</p>
                        <p id="stat-money" class="text-3xl font-bold text-purple-300">$0</p>
                    </div>
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-6 border border-gray-700">
                        <p class="text-gray-400">Lives Left</p>
                        <p id="stat-lives" class="text-3xl font-bold text-green-300">0</p>
                    </div>
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-6 border border-gray-700">
                        <p class="text-gray-400">Turrets Placed</p>
                        <p id="stat-turrets" class="text-3xl font-bold text-blue-300">0</p>
                    </div>
                    <div class="bg-gray-800 bg-opacity-70 rounded-xl p-6 border border-gray-700">
                        <p class="text-gray-400">Time</p>
                        <p id="stat-time" class="text-3xl font-bold text-white">0s</p>
                    </div>
                </div>
                <div class="flex justify-end space-x-4 mt-6">
                    <button id="message-button-1" class="game-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg">Next Level</button>
                    <button id="message-button-2" class="game-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg">Main Menu</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Debug Menu (Press 'D' to toggle) -->
    <div id="debug-menu" class="hidden fixed top-4 right-4 bg-yellow-900 bg-opacity-95 border-2 border-yellow-500 rounded-lg shadow-2xl p-4 z-50 min-w-[250px]">
        <div class="flex justify-between items-center mb-3">
            <h3 class="text-lg font-bold text-yellow-200">Debug Menu</h3>
            <button id="debug-close" class="text-yellow-200 hover:text-white font-bold text-xl">&times;</button>
        </div>
        <div class="space-y-2 text-sm">
            <div class="text-yellow-300 mb-2">Press 'D' to toggle</div>
            <button id="debug-add-gems" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">+100 Gems</button>
            <button id="debug-add-money" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">+1000 Money</button>
            <button id="debug-unlock-all" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">Unlock All Turrets</button>
            <button id="debug-max-all" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">Max All Turret Levels</button>
            <button id="debug-add-lives" class="w-full game-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded">+10 Lives</button>
        </div>
    </div>

</body>
</html>
